<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZSpirytus的博客</title>
  <icon>https://www.gravatar.com/avatar/5427c5380bea56f0a9fb2a5fada097e9</icon>
  <subtitle>这里是ZSpirytus的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.zspirytus.com/"/>
  <updated>2019-08-03T16:58:53.413Z</updated>
  <id>www.zspirytus.com/</id>
  
  <author>
    <name>ZSpirytus</name>
    <email>zhanwel261717@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记Android层执行Lua脚本的一次实践</title>
    <link href="www.zspirytus.com/AndroidLua/"/>
    <id>www.zspirytus.com/AndroidLua/</id>
    <published>2019-07-23T06:41:24.000Z</published>
    <updated>2019-08-03T16:58:53.413Z</updated>
    
    <content type="html"><![CDATA[<img src="/AndroidLua/cover.jpg"><h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;最近一直在写Lua脚本，有时候出了问题，不知道是Lua层的问题，还是上游的问题，不知道从何下手。于是我学习了一点C/C++和JNI，把整个解析Lua脚本包、执行Lua脚本的流程全部都读了一遍。熟悉了一遍之后，就萌生了自己封一个Android跑Lua脚本库的想法。于是就有这篇博文。C/C++和Kotlin我都不熟，所以这次我主要用这两种语言来写（所以会很Java Style）。</p><a id="more"></a><h1 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h1><p>首先现在Lua<a href="https://www.lua.org/download.html" target="_blank" rel="noopener">官网</a>下载Lua的源码，我用的是5.3.5版本的。然后把源码导入到Project中，写好CMakeList：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For more information about using CMake with Android Studio, read the</span></span><br><span class="line"><span class="comment"># documentation: https://d.android.com/studio/projects/add-native-code.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets the minimum version of CMake required to build the native library.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates and names a library, sets it as either STATIC</span></span><br><span class="line"><span class="comment"># or SHARED, and provides the relative paths to its source code.</span></span><br><span class="line"><span class="comment"># You can define multiple libraries, and CMake builds them for you.</span></span><br><span class="line"><span class="comment"># Gradle automatically packages shared libraries with your APK.</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-Wno-deprecated)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>( <span class="comment"># Sets the name of the library.</span></span><br><span class="line">        luabridge</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Sets the library as a shared library.</span></span><br><span class="line">        SHARED</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Provides a relative path to your source file(s).</span></span><br><span class="line">        src/main/jni/lua/lapi.c</span><br><span class="line">        src/main/jni/lua/lauxlib.c</span><br><span class="line">        src/main/jni/lua/lbaselib.c</span><br><span class="line">        src/main/jni/lua/lbitlib.c</span><br><span class="line">        src/main/jni/lua/lcode.c</span><br><span class="line">        src/main/jni/lua/lcorolib.c</span><br><span class="line">        src/main/jni/lua/lctype.c</span><br><span class="line">        src/main/jni/lua/ldblib.c</span><br><span class="line">        src/main/jni/lua/ldebug.c</span><br><span class="line">        src/main/jni/lua/ldo.c</span><br><span class="line">        src/main/jni/lua/ldump.c</span><br><span class="line">        src/main/jni/lua/lfunc.c</span><br><span class="line">        src/main/jni/lua/lgc.c</span><br><span class="line">        src/main/jni/lua/linit.c</span><br><span class="line">        src/main/jni/lua/liolib.c</span><br><span class="line">        src/main/jni/lua/llex.c</span><br><span class="line">        src/main/jni/lua/lmathlib.c</span><br><span class="line">        src/main/jni/lua/lmem.c</span><br><span class="line">        src/main/jni/lua/loadlib.c</span><br><span class="line">        src/main/jni/lua/lobject.c</span><br><span class="line">        src/main/jni/lua/lopcodes.c</span><br><span class="line">        src/main/jni/lua/loslib.c</span><br><span class="line">        src/main/jni/lua/lparser.c</span><br><span class="line">        src/main/jni/lua/lstate.c</span><br><span class="line">        src/main/jni/lua/lstring.c</span><br><span class="line">        src/main/jni/lua/lstrlib.c</span><br><span class="line">        src/main/jni/lua/ltable.c</span><br><span class="line">        src/main/jni/lua/ltablib.c</span><br><span class="line">        src/main/jni/lua/ltm.c</span><br><span class="line">        src/main/jni/lua/lua.c</span><br><span class="line">        <span class="comment">#src/main/jni/lua/luac.c</span></span><br><span class="line">        src/main/jni/lua/lundump.c</span><br><span class="line">        src/main/jni/lua/lutf8lib.c</span><br><span class="line">        src/main/jni/lua/lvm.c</span><br><span class="line">        src/main/jni/lua/lzio.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Searches for a specified prebuilt library and stores the path as a</span></span><br><span class="line"><span class="comment"># variable. Because CMake includes system libraries in the search path by</span></span><br><span class="line"><span class="comment"># default, you only need to specify the name of the public NDK library</span></span><br><span class="line"><span class="comment"># you want to add. CMake verifies that the library exists before</span></span><br><span class="line"><span class="comment"># completing its build.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_library</span>( <span class="comment"># Sets the name of the path variable.</span></span><br><span class="line">        log-lib</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Specifies the name of the NDK library that</span></span><br><span class="line">        <span class="comment"># you want CMake to locate.</span></span><br><span class="line">        log)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies libraries CMake should link to your target library. You</span></span><br><span class="line"><span class="comment"># can link multiple libraries, such as libraries you define in this</span></span><br><span class="line"><span class="comment"># build script, prebuilt third-party libraries, or system libraries.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>( <span class="comment"># Specifies the target library.</span></span><br><span class="line">        luabridge</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Links the target library to the log library</span></span><br><span class="line">        <span class="comment"># included in the NDK.</span></span><br><span class="line">        <span class="variable">$&#123;log-lib&#125;</span>)</span><br></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;我要跑是 <strong>*.lua</strong> 类型的脚本，那就留下<strong>lua.c</strong>并删掉<strong>luac.c</strong>，CMakeList里面也要跟着注释掉。另外，因为我把Lua的源代码导入进来当做一个库，所以也不需要main方法了，把lua.c里面的main方法注释掉。最后Rebuild一下Project就可以了。</p><h1 id="2-Android单向调用Lua"><a href="#2-Android单向调用Lua" class="headerlink" title="2. Android单向调用Lua"></a>2. Android单向调用Lua</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;先定一个小目标，Android层调用Lua层的函数，Lua层做一个加法后把结果返回给Android层。先写好Lua脚本：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;这个Lua脚本很简单，把传过来的a和b相加后返回。现在我们可以开始考虑Native层的实现。在考虑实现之前，需要了解Lua虚拟栈和几个Lua C API。</p><h2 id="2-1-Lua虚拟栈"><a href="#2-1-Lua虚拟栈" class="headerlink" title="2.1. Lua虚拟栈"></a>2.1. Lua虚拟栈</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Lua层和Native层的数据交换是通过Lua虚拟栈来完成的。这个虚拟栈和普通的栈略有不同，它可以通过负值索引来访问指定元素。如图：<br><img src="/AndroidLua/lua_stack.png" title="Lua虚拟栈"><br>&nbsp;&nbsp;&nbsp;&nbsp;和普通的栈一样，Lua虚拟栈同样遵循先进后出原则，索引从下往上增加。不同的是Lua虚拟栈支持负值索引，使用负值索引可以自栈顶向下索引。</p><h2 id="2-2-Lua-C-APIs"><a href="#2-2-Lua-C-APIs" class="headerlink" title="2.2. Lua C APIs"></a>2.2. Lua C APIs</h2><p>Lua提供了C APIs，方便Native层和Lua层之间的通讯。下面的Demo会用到这几个C API。</p><ul><li><p>lua_State *luaL_newstate (void);</p><p>新建一个Lua的context。</p></li><li><p>int luaL_loadbuffer (lua_State *L, const char *buff, size_t sz, const char *name);</p><p>编译一个Lua chunk。如果编译成功，它会把编译结果包装成一个函数，并把这个函数推入到栈中；否则，编译失败，它会把错误信息推入栈中。</p><p>| 参数   | 类型 |      说明      |<br>|:———-:|:———-:|————-|<br>| L |  lua_State* | Lua的context |<br>| buff |    const char* | 需要加载的Lua脚本buffer   |<br>| sz |    size_t | Lua脚本buffer的长度   |<br>| name |    const char* | 这个chunk的名称，可空   |</p></li><li><p>int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);</p><p>以安全模式调用一个函数，即使抛出异常也不会崩溃。当抛出异常时，如果errfunc为0，Lua虚拟机会把错误信息推入到Lua虚拟栈中，如果errfunc不为0，则错误处理会交由Lua虚拟栈中索引为errfunc的函数处理。执行结束后，Lua虚拟机会把参数以及调用的函数从栈中弹出。</p><p>| 参数   | 类型 |      说明      |<br>|:———-:|:———-:|————-|<br>| L |  lua_State* | Lua的context |<br>| nargs |    int | 需要调用的函数的参数个数   |<br>| nresults |    int | 需要调用的函数的返回结果个数   |<br>| errfunc |    int |  错误处理函数在Lua虚拟栈中的索引，如果为0，错误信息会推入到Lua虚拟栈中   |</p></li><li><p>void lua_getglobal (lua_State *L, const char *name);</p><p>获取名字为name的全局变量，并推入栈中。</p><p>| 参数   | 类型 |      说明      |<br>|:———-:|:———-:|————-|<br>| L |  lua_State* | Lua的context |<br>| name |    const char* | 变量名称   |</p></li><li><p>void lua_pushinteger (lua_State *L, lua_Integer n);</p></li><li><p>   推入一个lua_Integer类型的数据到栈中</p><p>   | 参数   | 类型 |      说明      |<br>   |:———-:|:———-:|————-|<br>   | L |  lua_State* | Lua的context |<br>   | n |    lua_Integer | 需要推入的数字   |  </p></li><li><p>lua_Integer lua_tointeger (lua_State *L, int index); </p><p>将栈中的索引为index的元素转lua_Integer并返回</p><p>| 参数   | 类型 |      说明      |<br>|:———-:|:———-:|————-|<br>| L |  lua_State* | Lua的context |<br>| index |    int | 指定元素在栈中的索引   | </p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;除了这些C API，其他的介绍及其用法可以查看官网的<a href="https://www.lua.org/manual/5.1/manual.html#3.7" target="_blank" rel="noopener">说明</a>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;通过理解Lua虚拟栈和了解一些Lua C API，我们就可以实现一个简单的Native层调用Lua层函数的功能。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jint <span class="title">startScript</span><span class="params">(JNIEnv* env, jobject obj, jstring jLuaStr, jint a, jint b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个lua context</span></span><br><span class="line">    lua_State* luaContext = lua_newstate();</span><br><span class="line">    <span class="comment">// 初始化lua lib</span></span><br><span class="line">    luaL_openlibs(luaContext);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* cLuaStr = env-&gt;GetStringUTFChars(jLuaStr, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载buff到内存</span></span><br><span class="line">    <span class="keyword">int</span> loadStatus = luaL_loadbuffer(luaContext, cLuaStr, <span class="built_in">strlen</span>(cLuaStr), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (LUA_OK != loadStatus) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *szError = luaL_checkstring(luaContext, <span class="number">-1</span>);</span><br><span class="line">        Log_e(LOG_TAG, <span class="string">"%s"</span>, szError);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(jLuaStr, cLuaStr);</span><br><span class="line">    <span class="keyword">int</span> callStatus = lua_pcall(luaContext, <span class="number">0</span>, LUA_MULTRET, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (LUA_OK != callStatus) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *szError = luaL_checkstring(luaContext, <span class="number">-1</span>);</span><br><span class="line">        Log_e(LOG_TAG, <span class="string">"%s"</span>, szError);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取test方法</span></span><br><span class="line">    lua_getglobal(luaContext, <span class="string">"test"</span>);</span><br><span class="line">    <span class="keyword">if</span> (LUA_TFUNCTION != lua_type(luaContext, <span class="number">-1</span>)) &#123;</span><br><span class="line">        Log_d(LOG_TAG, <span class="string">"can not found func : %s"</span>, <span class="string">"test"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 推入参数</span></span><br><span class="line">    lua_pushinteger(luaContext, a);</span><br><span class="line">    lua_pushinteger(luaContext, b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行test方法</span></span><br><span class="line">    <span class="keyword">int</span> callTestStatus = lua_pcall(luaContext, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(LUA_OK == callTestStatus) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = lua_tointeger(luaContext, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* errMsg = lua_tostring(luaContext, <span class="number">1</span>)</span><br><span class="line">        Log_e(LOG_TAG, <span class="string">"%s"</span>, errMsg);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;流程如注释。在这一个过程中，Lua虚拟栈的内容变化如图，从<strong>luaL_loadbuffer</strong>开始：<br><img src="/AndroidLua/lua_stack_content_change.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;首先，经过luaL_loadbuffer之后，luaL_loadbuffer会把传过来的*.lua文件的buffer作为一个Lua Chunk，接着编译它。编译完后，把编译结果包装成一个function并推入Lua虚拟栈中。经过lua_pcall后，Lua虚拟机会把所执行的function及其参数从Lua虚拟栈中弹出。接着，通过lua_getglobal获取Lua层的全局变量「test」，lua_getglobal会把这个变量的值推入Lua虚拟栈中。函数已经准备好，再经过lua_pushinteger(a)和lua_pushinteger(b)后，函数和参数都已经顺序推入了，调用lua_pcall的先决条件已经满足。接下来，调用lua_pcall后，Lua虚拟机会根据调用lua_pcall是传入的nresults，将结果推入Lua虚拟栈中。最后，我们只需要lua_tointeger(index)来获取执行结果，返回给Android层即可。可以看到，自始至终，Lua虚拟栈充当一个数据交换的桥梁，是一个十分重要的角色。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;接下来，只需要在Native层Register一下NativeMethods，并在Android层声明一下native方法就可以使用了。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LuaExecutor</span> </span>&#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"luabridge"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    external <span class="function"><span class="keyword">fun</span> <span class="title">startScript</span><span class="params">(luaString: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;然而，上面的实现只有启动脚本的功能。在实际中，我们总不可能启动脚本之后，就没有对脚本执行流程有一点控制吧。因此有必要加一个停止脚本的功能。如何停止正在执行的脚本？先来看看Lua提供的C API：</p><ul><li><p>int luaL_error (lua_State *L, const char *fmt, …);</p><p>   抛出一个异常，错误信息为fmt。</p><p>   | 参数   | 类型 |      说明      |<br>   |:———-:|:———-:|————-|<br>   | L |  lua_State* | Lua的context |<br>   | fmt |    const char* | 错误信息   |</p></li><li><p>int lua_sethook (lua_State *L, lua_Hook f, int mask, int count);</p><p>设置一个钩子函数。</p><p>| 参数   | 类型 |      说明      |<br>|:———-:|:———-:|————-|<br>| L |  lua_State* | Lua的context |<br>| f |    lua_Hook | 钩子函数，包含需要执行的语句   |<br>| mask |    int | 指定被调用的时机，取值为常量LUA_MASKCALL，LUA_MASKRET，LUA_MASKLINE和LUA_MASKCOUNT的按位或。   | </p><p>| mask取值   |      说明      |<br>|:———-:|————-|<br>| LUA_MASKCALL |  代表钩子函数f会在进入任意函数后执行 |<br>| LUA_MASKRET |    代表钩子函数在退出任意函数前执行   |<br>| LUA_MASKLINE |    代表钩子函数f会在执行函数内一行代码前执行   |<br>| LUA_MASKCOUNT |    代表钩子函数f会在lua解释器执行了count条指令后执行   | </p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;有了这两个C API，脚本的停止功能就可以实现了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stopLuaHooker</span><span class="params">(lua_State *L, lua_Debug *ar)</span> </span>&#123;</span><br><span class="line">    luaL_error(L, <span class="string">"quit Lua"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forceStopLua</span><span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = LUA_MASKCOUNT;</span><br><span class="line">    lua_sethook(L, &amp;stopLuaHooker, mask, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;当我们调用forceStopLua时，会为Lua脚本的执行设置一个钩子函数，这个钩子函数的执行时机是：lua_sethook执行之后，Lua解释器执行完一条指令时。也就是说，我们在Lua层代码执行到任意地方时调用forceStopLua后，Lua解释器会在执行完一条指令后，接着执行stopLuaHooker，进而执行lua_error，抛出异常，脚本即终止。因此，脚本的启动和停止的功能已经实现好了，封到一个类里，叫做LuaEngine：<br><figure class="highlight c"><figcaption><span>LuaEngine.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ANDROIDLUA_LUAENGINE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROIDLUA_LUAENGINE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lua/lua.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"utils/Log.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"JniManager.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_TAG <span class="meta-string">"LuaEngine"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LuaEngine</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LuaEngine();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~LuaEngine();</span><br><span class="line"></span><br><span class="line">    <span class="function">lua_State *<span class="title">getScriptContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mScriptContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startScript</span><span class="params">(jstring jBuff, <span class="keyword">const</span> <span class="keyword">char</span> *functionName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isScriptRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scriptRunning;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stopScript</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    lua_State *mScriptContext;</span><br><span class="line">    <span class="keyword">bool</span> scriptRunning;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">loadBuff</span><span class="params">(jstring jBuff)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">runLuaFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *functionName)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quitLuaThread</span><span class="params">(lua_State *L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quitLuaThreadHooker</span><span class="params">(lua_State *L, lua_Debug *ar)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//ANDROIDLUA_LUAENGINE_H</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight c"><figcaption><span>LuaEngine.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LuaEngine.h"</span></span></span><br><span class="line"></span><br><span class="line">LuaEngine::LuaEngine() &#123;</span><br><span class="line">    mScriptContext = luaL_newstate();</span><br><span class="line">    scriptRunning = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LuaEngine::~LuaEngine() &#123;</span><br><span class="line">    <span class="keyword">if</span> (isScriptRunning()) &#123;</span><br><span class="line">        stopScript();</span><br><span class="line">    &#125;</span><br><span class="line">    mScriptContext = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> LuaEngine::startScript(jstring jBuff, <span class="keyword">const</span> <span class="keyword">char</span> *functionName) &#123;</span><br><span class="line">    scriptRunning = <span class="literal">true</span>;</span><br><span class="line">    luaL_openlibs(mScriptContext);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;loadBuff(jBuff)) &#123;</span><br><span class="line">        Log_d(LOG_TAG, <span class="string">"script start running.."</span>);</span><br><span class="line">        <span class="keyword">bool</span> success = <span class="keyword">this</span>-&gt;runLuaFunction(functionName);</span><br><span class="line">        scriptRunning = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        scriptRunning = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> LuaEngine::stopScript() &#123;</span><br><span class="line">    <span class="keyword">if</span> (scriptRunning) &#123;</span><br><span class="line">        quitLuaThread(mScriptContext);</span><br><span class="line">        scriptRunning = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log_d(LOG_TAG, <span class="string">"script is Not running"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> LuaEngine::loadBuff(jstring jBuff) &#123;</span><br><span class="line">    <span class="comment">// 读取buff</span></span><br><span class="line">    JNIEnv *env;</span><br><span class="line">    JniManager::getInstance()-&gt;getJvm()-&gt;GetEnv((<span class="keyword">void</span> **) &amp;env, JNI_VERSION_1_6);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cBuff = env-&gt;GetStringUTFChars(jBuff, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (LUA_OK != luaL_loadbuffer(mScriptContext, cBuff, <span class="built_in">strlen</span>(cBuff), <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *szError = luaL_checkstring(mScriptContext, <span class="number">-1</span>);</span><br><span class="line">        Log_e(LOG_TAG, <span class="string">"%s"</span>, szError);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加载buff到内存</span></span><br><span class="line">    <span class="keyword">if</span> (LUA_OK != lua_pcall(mScriptContext, <span class="number">0</span>, LUA_MULTRET, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *szError = luaL_checkstring(mScriptContext, <span class="number">-1</span>);</span><br><span class="line">        Log_e(LOG_TAG, <span class="string">"%s"</span>, szError);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(jBuff, cBuff);</span><br><span class="line">    env-&gt;DeleteGlobalRef(jBuff);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> LuaEngine::runLuaFunction(<span class="keyword">const</span> <span class="keyword">char</span> *functionName) &#123;</span><br><span class="line">    <span class="comment">// 获取errorFunc</span></span><br><span class="line">    <span class="comment">// 错误由__TRACKBACK__来处理，可以用来打印错误信息，</span></span><br><span class="line">    <span class="comment">// __TRACKBACK__函数需要自己定义在lua脚本中</span></span><br><span class="line">    lua_getglobal(mScriptContext, <span class="string">"__TRACKBACK__"</span>);</span><br><span class="line">    <span class="keyword">if</span> (lua_type(mScriptContext, <span class="number">-1</span>) != LUA_TFUNCTION) &#123;</span><br><span class="line">        Log_d(LOG_TAG, <span class="string">"can not found errorFunc : __TRACKBACK__"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> errfunc = lua_gettop(mScriptContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定的方法</span></span><br><span class="line">    lua_getglobal(mScriptContext, functionName);</span><br><span class="line">    <span class="keyword">if</span> (lua_type(mScriptContext, <span class="number">-1</span>) != LUA_TFUNCTION) &#123;</span><br><span class="line">        Log_d(LOG_TAG, <span class="string">"can not found func : %s"</span>, functionName);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跑指定的方法</span></span><br><span class="line">    <span class="keyword">return</span> LUA_OK == lua_pcall(mScriptContext, <span class="number">0</span>, <span class="number">0</span>, errfunc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quitLuaThread</span><span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = LUA_MASKCOUNT;</span><br><span class="line">    lua_sethook(L, &amp;quitLuaThreadHooker, mask, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quitLuaThreadHooker</span><span class="params">(lua_State *L, lua_Debug *ar)</span> </span>&#123;</span><br><span class="line">    luaL_error(L, <span class="string">"quit Lua"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-Lua单向调用Android"><a href="#3-Lua单向调用Android" class="headerlink" title="3. Lua单向调用Android"></a>3. Lua单向调用Android</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;前面的实现，只允许Android层调用Lua的方法，而Lua层并不能调用Android层的方法。可不可以在Lua层调用Android层的方法？答案是可以的。一个思路是，Lua层调用Native层的方法，Native层再通过反射调用Android层的方法。先看看Lua层是怎么调用Native层的方法。Lua提供了一个C API：lua_register，它的原型是：</p><ul><li><p>void lua_register (lua_State *L, const char *name, lua_CFunction f);</p><p>   注册一个CFunction。</p><p>   | 参数   | 类型 |      说明      |<br>   |:———-:|:———-:|————-|<br>   | L |  lua_State* | Lua的context |<br>   | name |    const char* | Lua层全局变量的名称  |<br>   | f |    lua_CFunction | C函数。原型是：int functionXXX(lua_State* L);其返回值的意义代表返回结果的个数。   | </p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;我们可以用这个C API实现Lua层调用Native层的方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lua_register(mScriptContext, <span class="string">"getString"</span> , getString);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getString</span><span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cStr = <span class="string">"String From C Layer"</span>;</span><br><span class="line">    lua_pushstring(L, cStr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;上面的代码很简单，先注册一个名字为getString的全局变量，指向C函数getString。C函数getString中，先声明并分配一个字符串cStr，再把这个字符串推入到Lua栈中，并返回结果个数。因此，在Lua层，如果执行getString()，则会得到字符串”String From C Layer”，Lua层就可以调用Native层的方法了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;然后看看Native层调用Android层的方法。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getString</span><span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    g_pJvm-&gt;GetEnv((<span class="keyword">void</span> **) &amp;env, JNI_VERSION_1_6);</span><br><span class="line">    </span><br><span class="line">    jclass clazz = env-&gt;FindClass(<span class="string">"com/zspirytus/androidlua/shell/ShellBridge"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!clazz) &#123;</span><br><span class="line">        Log_d(LOG_TAG, <span class="string">"class not found!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    jmethodID methodId = env-&gt;GetStaticMethodID(clazz, <span class="string">"getStringFromKotlinLayer"</span>, <span class="string">"()Ljava/lang/String;"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!methodId) &#123;</span><br><span class="line">        Log_d(LOG_TAG, <span class="string">"method %s not found!"</span>, <span class="string">"getStringFromStaticJavaMethod"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    jstring jStr = (jstring) env-&gt;CallStaticObjectMethod(clazz, methodId);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cStr = env-&gt;GetStringUTFChars(jStr, <span class="literal">NULL</span>);</span><br><span class="line">    lua_pushstring(L, cStr);</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(jStr, cStr);</span><br><span class="line">    env-&gt;DeleteLocalRef(jStr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;解释一下，首先通过在JNI_OnLoad保存下来的JavaVM指针指针获得Jni的环境变量，再用Jni的环境变量找到class和method，最后通过env、class和method反射调用Android层的方法获得返回的jstring，转成C-style的string后推入lua栈中，释放资源，并返回结果个数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;在Android层，留下一个方法以供调用：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Keep</span></span><br><span class="line"><span class="keyword">object</span> ShellBridge &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = ShellBridge.javaClass.simpleName</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Keep</span></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getStringFromKotlinLayer</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"String From Android Layer"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>至此，Android层与Lua层的交互已经实现了。</p><h1 id="4-避免ANR"><a href="#4-避免ANR" class="headerlink" title="4. 避免ANR"></a>4. 避免ANR</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;然而上面的实现可能会导致ANR，原因在于Lua脚本的执行可能是耗时的。如果Lua脚本的执行时间超过5秒，必然ANR。一个解决方法是，把Lua脚本的执行放到子线程当中。这个子线程应当给Native层管理比较好，还是Android层管理比较好？我个人觉得放在Native层比较好，这样Android层就不需要专为执行Lua脚本而新建和管理线程，代码就不会太复杂；即使Native层的逻辑比较复杂，编好了so，一般就会当做一个库来使用，而不会去动它。所以，还是在Native层创建和管理线程。<br>pthread_create是Unix、Linux等系统创建线程的函数，它的原型是：</p><ul><li><p>int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, void *(*start_rtn)(void *), void *restrict arg);</p><p>   | 参数   | 类型 |      说明      |<br>   |:———-:|:———-:|————-|<br>   | tidp |  pthread_t *restrict | 线程ID |<br>   | attr |    const pthread_attr_t*restrict | 线程属性，默认为NULL  |<br>   | *(*start_rtn)(void *) |    void | 运行在新线程的函数   |<br>   | *restrict arg |  void | start_rtn的所需参数 | </p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;因此，我们可以把执行Lua脚本的逻辑移到新线程中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pthread_create(&amp;mThreadId, <span class="literal">NULL</span>, &amp;startWorkInner, (<span class="keyword">void</span>*)<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stopWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stopScript();</span><br><span class="line">    mThreadId = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">startWorkInner</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">    startScript();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;这样，startScript()就运行在新线程中，就不会有ANR的风险。我们把它封到一个类中，叫LuaTask，一次Lua脚本的开始与结束，都由这个类来管理。<br><figure class="highlight c"><figcaption><span>LuaTask.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ANDROIDLUA_LUATASK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROIDLUA_LUATASK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LuaEngine.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LuaTask</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LuaTask(jstring jBuff);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~LuaTask();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stopWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">startWorkInner</span><span class="params">(<span class="keyword">void</span> *args)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    jstring mLuaBuff;</span><br><span class="line">    <span class="keyword">pthread_t</span> mThreadId;</span><br><span class="line">    LuaEngine *mLuaEngine;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//ANDROIDLUA_LUATASK_H</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight c"><figcaption><span>LuaTask.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LuaTask.h"</span></span></span><br><span class="line"></span><br><span class="line">LuaTask::LuaTask(jstring jBuff) &#123;</span><br><span class="line">    mLuaBuff = jBuff;</span><br><span class="line">    mLuaEngine = <span class="keyword">new</span> LuaEngine();</span><br><span class="line">    mThreadId = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LuaTask::~LuaTask() &#123;</span><br><span class="line">    <span class="keyword">delete</span> mLuaEngine;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LuaTask::startWork() &#123;</span><br><span class="line">    pthread_create(&amp;mThreadId, <span class="literal">NULL</span>, &amp;LuaTask::startWorkInner, (<span class="keyword">void</span>*)<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LuaTask::stopWork() &#123;</span><br><span class="line">    mLuaEngine-&gt;stopScript();</span><br><span class="line">    mThreadId = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* LuaTask::startWorkInner(<span class="keyword">void</span> *args) &#123;</span><br><span class="line">    LuaTask* task = (LuaTask*) args;</span><br><span class="line">    task-&gt;mLuaEngine-&gt;startScript(task-&gt;mLuaBuff, <span class="string">"main"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> LuaTask::isRunning() &#123;</span><br><span class="line">    <span class="keyword">return</span> mThreadId != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;但是，这是我们新创建的线程，还没有attach到JavaVM。如果没有attach到JavaVM，就会找不到JNIEnv，所以必须要attach到JavaVM，这样才能拿到JavaVM的JNI环境变量，从而可以调用到Android层的方法。因此startWorkInner要改进一下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">startWorkInner</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">    JNIEnv* env = <span class="literal">nullptr</span>;</span><br><span class="line">    JavaVMAttachArgs args&#123;JNI_VERSION_1_6, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    g_pJvm-&gt;AttachCurrentThread(&amp;env, &amp;args);</span><br><span class="line">    startScript()</span><br><span class="line">    g_pJvm-&gt;DetachCurrentThread();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;线程退出之前，记得要和JavaVM detach一下，这样线程才能正常退出。</p><h1 id="5-运行脚本包"><a href="#5-运行脚本包" class="headerlink" title="5. 运行脚本包"></a>5. 运行脚本包</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;至此，我们完成了能够随时开始、停止，出错能打印堆栈信息的执行Lua脚本功能。但实际上，我们不可能只跑单个脚本，并且脚本可能需要一些资源文件。因此我们一般会把脚本和资源文件打包成一个脚本包。在运行脚本之前，先解包，把脚本解析出来后再运行。<br>所以这个解析脚本的逻辑放在Native层还是Android层？我个人觉得放在Android层比较好。有两点原因：</p><ol><li>脚本包格式不确定，Native层不可能为每种情况进行适配，既然如此那就交由使用者来解析。</li><li>单一职责的原则，Native层负责还是只负责一种功能比较好。而且为解析脚本包而重新编译一个so文件又太小题大做，所以解析的任务就交给使用者吧。</li></ol><p>既然提到脚本包，我就简单谈谈我的实现。我的实现是把lua脚本和资源文件一起压缩成一个zip文件，在zip文件中有一个config文件，里面写好了所有lua脚本的相对路径。在解析的时候，先在内存中把config解压出来，读出所有lua脚本的相对路径，然后在内存中把所有lua脚本文件都解压出来后，拼接起来，在交给Native层运行。至于资源文件，根据脚本的运行情况进行动态解压。我简单的封装了一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">private external fun startScript(luaString: String): Boolean</span><br><span class="line">external fun stopScript(): Boolean</span><br><span class="line">external fun isScriptRunning(): Boolean</span><br><span class="line"></span><br><span class="line">fun runScriptPkg(scriptPkg: File, configFile: String) &#123;</span><br><span class="line">    mThreadPool?.execute &#123;</span><br><span class="line">        val start = System.currentTimeMillis()</span><br><span class="line">        initScriptPkg(scriptPkg)</span><br><span class="line">        val zipFile = ZipFile(scriptPkg)</span><br><span class="line">        val config = ZipFileUtils.getFileContentFromZipFile(zipFile, configFile)</span><br><span class="line">        val luaScriptPaths = config.split(&quot;\r\n&quot;)</span><br><span class="line">        val luaScript = ZipFileUtils.getFilesContentFromZipFile(zipFile, luaScriptPaths)</span><br><span class="line">        Log.d(&quot;USE_TIME&quot;, &quot;$&#123;System.currentTimeMillis() - start&#125; ms&quot;)</span><br><span class="line">        mHandler?.post &#123;</span><br><span class="line">            startScript(luaScript)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object ZipFileUtils &#123;</span><br><span class="line"></span><br><span class="line">    fun getFileContentFromZipFile(zipFile: ZipFile, targetFile: String): String &#123;</span><br><span class="line">        var ins: InputStream? = null</span><br><span class="line">        try &#123;</span><br><span class="line">            val ze = zipFile.getEntry(targetFile)</span><br><span class="line">            return if (ze != null) &#123;</span><br><span class="line">                ins = zipFile.getInputStream(ze)</span><br><span class="line">                FileUtils.readInputStream(ins)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            ins?.close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun getFilesContentFromZipFile(zipFile: ZipFile, targetFiles: List&lt;String&gt;): String &#123;</span><br><span class="line">        val stringBuilder = StringBuilder()</span><br><span class="line">        targetFiles.filter &#123; it.isNotEmpty() and it.isNotBlank() &#125;.forEach &#123;</span><br><span class="line">            val content = getFileContentFromZipFile(zipFile, it)</span><br><span class="line">            stringBuilder.append(content).append(&apos;\n&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">        return stringBuilder.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object FileUtils &#123;</span><br><span class="line"></span><br><span class="line">    fun readInputStream(ins: InputStream): String &#123;</span><br><span class="line">        return ins.bufferedReader().use(BufferedReader::readText)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;至此，我们在原有功能的基础上，增加了跑脚本包的功能。完整的代码可以看<a href="https://github.com/zkw012300/AndroidLua" target="_blank" rel="noopener">这里</a>。</p><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><img src="/AndroidLua/Android_call_lua.png"><img src="/AndroidLua/lua_call_android.png"><h1 id="7-感想"><a href="#7-感想" class="headerlink" title="7. 感想"></a>7. 感想</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;Android跑Lua脚本这个过程其实是很简单的，不是主要难点。这次主要卡住的地方是在JNI部分，因为我发现我所了解的C语言语法太古老了，跟不上现在的C语言。虽然我的C语言的代码量也不多，加上我对JNI的一些编程规范不太了解，所以一路磕磕绊绊，但是总算是写出来了。Kotlin和C/C++还是要多熟悉熟悉，多练练。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/AndroidLua/cover.jpg&quot;&gt;
&lt;h1 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;最近一直在写Lua脚本，有时候出了问题，不知道是Lua层的问题，还是上游的问题，不知道从何下手。于是我学习了一点C/C++和JNI，把整个解析Lua脚本包、执行Lua脚本的流程全部都读了一遍。熟悉了一遍之后，就萌生了自己封一个Android跑Lua脚本库的想法。于是就有这篇博文。C/C++和Kotlin我都不熟，所以这次我主要用这两种语言来写（所以会很Java Style）。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Lua语言学习笔记</title>
    <link href="www.zspirytus.com/lua-impression/"/>
    <id>www.zspirytus.com/lua-impression/</id>
    <published>2019-04-26T12:48:21.000Z</published>
    <updated>2019-07-28T12:46:00.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>最近学习了Lua语言，记录一下自己觉得对几个重要概念的学习过程。</p><a id="more"></a><h1 id="1-Table"><a href="#1-Table" class="headerlink" title="1. Table"></a>1. Table</h1><p>table是Lua语言的一个重要的数据结构。它很像一个Map，我们可以通过给出一个key来获得对应的value。并且，table的key可以是除nil以外的任意类型。看代码：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> tab = &#123;&#125;</span><br><span class="line"></span><br><span class="line">tab.a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">tab[<span class="string">'b'</span>] = <span class="string">'233'</span></span><br><span class="line"></span><br><span class="line">tab[f] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'call a function'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(tab) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">'tab.%s = %s'</span>, <span class="built_in">tostring</span>(k), <span class="built_in">tostring</span>(v)))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Output:</span></span><br><span class="line"><span class="comment">-- tab.a = 1</span></span><br><span class="line"><span class="comment">-- tab.b = 233</span></span><br><span class="line"><span class="comment">-- tab.f = function</span></span><br></pre></td></tr></table></figure></p><p>Lua的table不止于此，还有很多骚操作。</p><h2 id="1-1-MetaTable"><a href="#1-1-MetaTable" class="headerlink" title="1.1. MetaTable"></a>1.1. MetaTable</h2><p>MetaTable是Lua中元表。个人认为，元表是对table操作时触发的行为的集合。「触发的行为」是什么？它可以是一个function，定义这个行为做什么；也可以是一个table，定义这个行为的备选table。元表可以有很多属性，具体参照<a href="https://www.lua.org/pil/13.html" target="_blank" rel="noopener">官网</a>，我以__index为例。</p><h3 id="1-1-1-index"><a href="#1-1-1-index" class="headerlink" title="1.1.1. __index"></a>1.1.1. __index</h3><p>__index定义了在table中通过给定的key找到的value为nil时怎么办的行为。话不多说看代码：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> aTable = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> aMetatable = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(aTable.y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setmetatable</span>(aTable, aMetatable)</span><br><span class="line"><span class="built_in">print</span>(aTable.y)</span><br><span class="line"></span><br><span class="line">aMetatable.<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(t,k)</span></span></span><br><span class="line">    <span class="comment">-- t就是aTable</span></span><br><span class="line">    <span class="keyword">local</span> tempTable = &#123; y = <span class="number">666</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> tempTable[k]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(aTable.y)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Output:</span></span><br><span class="line"><span class="comment">-- nil</span></span><br><span class="line"><span class="comment">-- nil</span></span><br><span class="line"><span class="comment">-- 666</span></span><br></pre></td></tr></table></figure></p><p>首先先声明和定义两个table，aMetatable后面用作aTable的元表。元表同样也是一个表，所以这么声明没毛病。然后获取aTable的y属性的值，不用想，肯定是获得的是一个空值。接着，把aTable的元表设为aMetatable，然后再获取一次aTable的y属性的值。同样的，获得的是一个空值。为什么？因为aTable的元表没有任何可以触发的行为。那就为aTable的元表增加一个行为__index，在打印一个aTable的y属性的值，这会就打印出666了。总结一下这个过程：当我们访问aTable的y属性时，Lua虚拟机发现它是空值，所以他就会在aTable的元表中找到__index这个属性，如果这个属性是一个function，那就执行它，并把它的执行结果，返回作aTable的y属性的值。</p><p>当然上面的代码在设置元表时可以更加简化：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aMetatable.<span class="built_in">__index</span> = &#123; y = <span class="number">666</span> &#125;</span><br></pre></td></tr></table></figure></p><p>执行完这段语句，元表中__index这个行为就是一个table了。这个当我们访问aTable的y属性时，Lua虚拟机发现aTable.y是空的，就会去aMetatable.__index这个「表」里面把y作为key去取一个值并返回。这与上面的代码是等价的。</p><p>然而我总感觉还少了点什么，上面的代码，我只是根据输出来猜测它的行为，而不能确定它是怎么做到的。于是我在Lua的源代码里，全局搜索关键词「__index」，成功定位到__index的实现：<br><figure class="highlight c"><figcaption><span>lvm.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Finish the table access 'val = t[key]'.</span></span><br><span class="line"><span class="comment">** if 'slot' is NULL, 't' is not a table; otherwise, 'slot' points to</span></span><br><span class="line"><span class="comment">** t[k] entry (which must be nil).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaV_finishget</span> <span class="params">(lua_State *L, <span class="keyword">const</span> TValue *t, TValue *key, StkId val,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> TValue *slot)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> loop;  <span class="comment">/* counter to avoid infinite loops */</span></span><br><span class="line">  <span class="keyword">const</span> TValue *tm;  <span class="comment">/* metamethod */</span></span><br><span class="line">  <span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt; MAXTAGLOOP; loop++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (slot == <span class="literal">NULL</span>) &#123;  <span class="comment">/* 't' is not a table? */</span></span><br><span class="line">      lua_assert(!ttistable(t));</span><br><span class="line">      tm = luaT_gettmbyobj(L, t, TM_INDEX);</span><br><span class="line">      <span class="keyword">if</span> (ttisnil(tm))</span><br><span class="line">        luaG_typeerror(L, t, <span class="string">"index"</span>);  <span class="comment">/* no metamethod */</span></span><br><span class="line">      <span class="comment">/* else will try the metamethod */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* 't' is a table */</span></span><br><span class="line">      lua_assert(ttisnil(slot));</span><br><span class="line">      tm = fasttm(L, hvalue(t)-&gt;metatable, TM_INDEX);  <span class="comment">/* table's metamethod */</span></span><br><span class="line">      <span class="keyword">if</span> (tm == <span class="literal">NULL</span>) &#123;  <span class="comment">/* no metamethod? */</span></span><br><span class="line">        setnilvalue(val);  <span class="comment">/* result is nil */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* else will try the metamethod */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ttisfunction(tm)) &#123;  <span class="comment">/* is metamethod a function? */</span></span><br><span class="line">      luaT_callTM(L, tm, t, key, val, <span class="number">1</span>);  <span class="comment">/* call it */</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t = tm;  <span class="comment">/* else try to access 'tm[key]' */</span></span><br><span class="line">    <span class="keyword">if</span> (luaV_fastget(L,t,key,slot,luaH_get)) &#123;  <span class="comment">/* fast track? */</span></span><br><span class="line">      setobj2s(L, val, slot);  <span class="comment">/* done */</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* else repeat (tail call 'luaV_finishget') */</span></span><br><span class="line">  &#125;</span><br><span class="line">  luaG_runerror(L, <span class="string">"'__index' chain too long; possible loop"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解释一下，首先定义声明一个loop防止死循环，tm存储在元表中查找__index的结果。至于为什么要防止死循环可以不管，因为不是我们读源码的目的。接着定位到for循环内的第一个if-else分支，if分支内，注释说这是t不是一个table的情况。我们可以跳过，看看else分支，else分支是t是table的情况。else分支会去找table: t的元表，如果找到的元表为空，或者是元表中找不到__index属性，那就把结果设置为空，提前返回。如果找到了__index那就继续。接着看第二个if分支，如果__index是一个函数，那就用luaT_callTM调用它，luaT_callTM的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaT_callTM</span> <span class="params">(lua_State *L, <span class="keyword">const</span> TValue *f, <span class="keyword">const</span> TValue *p1,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> TValue *p2, TValue *p3, <span class="keyword">int</span> hasres)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">ptrdiff_t</span> result = savestack(L, p3);</span><br><span class="line">  StkId func = L-&gt;top;</span><br><span class="line">  setobj2s(L, func, f);  <span class="comment">/* push function (assume EXTRA_STACK) */</span></span><br><span class="line">  setobj2s(L, func + <span class="number">1</span>, p1);  <span class="comment">/* 1st argument */</span></span><br><span class="line">  setobj2s(L, func + <span class="number">2</span>, p2);  <span class="comment">/* 2nd argument */</span></span><br><span class="line">  L-&gt;top += <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> (!hasres)  <span class="comment">/* no result? 'p3' is third argument */</span></span><br><span class="line">    setobj2s(L, L-&gt;top++, p3);  <span class="comment">/* 3rd argument */</span></span><br><span class="line">  <span class="comment">/* metamethod may yield only when called from Lua code */</span></span><br><span class="line">  <span class="keyword">if</span> (isLua(L-&gt;ci))</span><br><span class="line">    luaD_call(L, func, hasres);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    luaD_callnoyield(L, func, hasres);</span><br><span class="line">  <span class="keyword">if</span> (hasres) &#123;  <span class="comment">/* if has result, move it to its place */</span></span><br><span class="line">    p3 = restorestack(L, result);</span><br><span class="line">    setobjs2s(L, p3, --L-&gt;top);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，luaT_callTM先把栈的状态保存起来，再把__index这个函数，及其第一个参数，第二个参数推入，因为hasres为1，所以第一个if分支不执行。接着，第二个if-else就调用__index方法。到了第三个if分支，因为hasres为1，所以会执行这个分支。这个if分支会还原栈的状态，并把结果赋值给p3，也就是上游传过来的val，然后把结果推入栈中。结束。<br>再回到luaV_finishget，到了最后一个if分支，看代码的意思，就是直接把__index当做一个table，在这个table中以给定的key查找value，并把查找结果返回。至此__index的实现原理就结束了。<br>结论是，如果__index是一个function，那就会把原table以及key传入给这个function，这个function处理后把结果返回，Lua虚拟机会把这个结果当做是查询结果；如果__index是一个table，那就用给定的key在__index中查询，并把结果返回。这和上面的猜测是相符的。</p><h2 id="1-2-Function的默认参数"><a href="#1-2-Function的默认参数" class="headerlink" title="1.2. Function的默认参数"></a>1.2. Function的默认参数</h2><p>我们初始化一个对象，这个对象里面可能有些属性不是必填的。比如一个person，它的属性name、age、sex都是必填的，而height、weight是选填的。我们很自然的就会这么定义一个函数来初始化person：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initPerson</span><span class="params">(name, age, sex, height, weight)</span></span></span><br><span class="line">    <span class="comment">-- 初始化..</span></span><br><span class="line">    <span class="keyword">local</span> person = getDefault()</span><br><span class="line">    person.name = name</span><br><span class="line">    person.age = age</span><br><span class="line">    person.sex = sex</span><br><span class="line">    person.height = height <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">    person.weight = weight <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> person</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printPerson</span><span class="params">( person )</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(</span><br><span class="line">            <span class="string">'name = %s, age = %d, sex = %s, height = %d, weight = %d'</span>, </span><br><span class="line">            person.name, </span><br><span class="line">            person.age, </span><br><span class="line">            person.sex, </span><br><span class="line">            person.height, </span><br><span class="line">            person.weight</span><br><span class="line">    ))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 仅传入必填属性</span></span><br><span class="line"><span class="keyword">local</span> p1 = initPerson(<span class="string">'Q1'</span>, <span class="number">23</span>, <span class="string">'female'</span>)</span><br><span class="line">printPerson(p1)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 传入必填属性+身高？</span></span><br><span class="line"><span class="keyword">local</span> p2 = initPerson(<span class="string">'Q2'</span>, <span class="number">23</span>, <span class="string">'female'</span>, <span class="number">169</span>)</span><br><span class="line">printPerson(p1)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 传入必填属性+体重？</span></span><br><span class="line"><span class="keyword">local</span> p3 = initPerson(<span class="string">'Q3'</span>, <span class="number">23</span>, <span class="string">'female'</span>, <span class="number">55</span>)</span><br><span class="line">printPerson(p1)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Output:</span></span><br><span class="line"><span class="comment">-- name = Q1, age = 23, sex = female, height = 0, weight = 0</span></span><br><span class="line"><span class="comment">-- name = Q2, age = 23, sex = female, height = 169, weight = 0</span></span><br><span class="line"><span class="comment">-- name = Q3, age = 23, sex = female, height = 55, weight = 0</span></span><br></pre></td></tr></table></figure></p><p>输出不符合我们的预期，因为Lua在传递参数是会把实参顺序推入到栈中，再按顺序对号入座到形参。如何解决默认参数的问题，我们可以传入一个table，这个table中以key为参数，value为参数的值。在初始化person的函数中，我们用key来在传来的table中取出对应参数的值，如果取出来的value为空，那就或一下，给它设置一个默认值就好了。代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initPerson</span><span class="params">( tPerson )</span></span></span><br><span class="line">    <span class="comment">-- 初始化..</span></span><br><span class="line">    <span class="keyword">local</span> person = getDefault()</span><br><span class="line">    person.name = tPerson.name</span><br><span class="line">    person.age = tPerson.age</span><br><span class="line">    person.sex = tPerson.sex</span><br><span class="line">    person.height = tPerson.height <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">    person.weight = tPerson.weight <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> person</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 仅传入必填属性</span></span><br><span class="line"><span class="keyword">local</span> p1 = initPerson(&#123;name = <span class="string">'Q1'</span>, age = <span class="number">23</span>, sex = <span class="string">'female'</span>&#125;)</span><br><span class="line">printPerson(p1)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 传入必填属性+身高？</span></span><br><span class="line"><span class="keyword">local</span> p2 = initPerson(&#123;name = <span class="string">'Q1'</span>, age = <span class="number">23</span>, sex = <span class="string">'female'</span>, height = <span class="number">169</span>&#125;)</span><br><span class="line">printPerson(p1)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 传入必填属性+体重？</span></span><br><span class="line"><span class="keyword">local</span> p3 = initPerson(&#123;name = <span class="string">'Q1'</span>, age = <span class="number">23</span>, sex = <span class="string">'female'</span>, weight = <span class="number">55</span>&#125;)</span><br><span class="line">printPerson(p1)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Output:</span></span><br><span class="line"><span class="comment">-- name = Q1, age = 23, sex = female, height = 0, weight = 0</span></span><br><span class="line"><span class="comment">-- name = Q2, age = 23, sex = female, height = 169, weight = 0</span></span><br><span class="line"><span class="comment">-- name = Q3, age = 23, sex = female, height = 0, weight = 55</span></span><br></pre></td></tr></table></figure><p>结果符合预期。不过，上面的代码，严格意义上来说，person的五个属性都成了可选参数，因为开发者是可能会忘了填name、age或sex属性。解决方法是：要么在开发的时候，开发者要知道name，age和sex一定要填值；要么就直接把name，age和sex单独抽出来，在加上一个table作为initPerson的参数列表，像这样<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initPerson</span><span class="params">(name, age, sex, tOptArgs )</span></span></span><br><span class="line">    <span class="comment">-- 初始化..</span></span><br><span class="line">    <span class="keyword">local</span> person = getDefault()</span><br><span class="line">    person.name = name</span><br><span class="line">    person.age = age</span><br><span class="line">    person.sex = sex</span><br><span class="line">    tOptArgs = tOptArgs <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    person.height = tOptArgs.height <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">    person.weight = tOptArgs.weight <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> person</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br>才能做到完美的必选参数+可选参数的初始化。</p><h1 id="2-Lua中的面向对象"><a href="#2-Lua中的面向对象" class="headerlink" title="2. Lua中的面向对象"></a>2. Lua中的面向对象</h1><p>Lua支持一定的OOP。Lua本身没有提供面向对象编程的支持，当时我们可以用Lua的一个重要数据结构「table」来模拟OOP的过程。不多说，上代码。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">MyObject = &#123;</span><br><span class="line">    name = <span class="string">"MyObject"</span>,</span><br><span class="line">    doWhat = <span class="string">"something"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject:newInstance</span><span class="params">( obj )</span></span></span><br><span class="line">    obj = obj <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    <span class="built_in">setmetatable</span>(obj, self)</span><br><span class="line">    self.<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(t,k)</span></span></span><br><span class="line">    <span class="keyword">return</span> self[k]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    obj.name = <span class="string">"Q"</span></span><br><span class="line">    obj.fieldB = <span class="string">"eat"</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">MyObject:doSomething</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">'%s do %s.'</span>, self.name, self.doWhat))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> oneObj = MyObject:newInstance()</span><br><span class="line">oneObj:doSomething()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Output:</span></span><br><span class="line"><span class="comment">-- Q do eat.</span></span><br></pre></td></tr></table></figure></p><p>MyObject这个表，有两个属性，name和doWhat，我们可以把它看做一个“类”；并且还定义了两个方法newInstance和doSomething。形如「XXX.xxx()」和「XXX:xxx()」的形式是Lua语言的语法糖，同样都是在“类”中声明一个函数：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// <span class="number">1</span></span><br><span class="line">Person.say = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">// <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person.say</span><span class="params">(self)</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">// <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person:say</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>上面的代码中，三者是等价的，同样为Person中的say属性赋值一个函数。对于1和2，2是Lua的语法糖，2等价于1。对于2和3，3是Lua的语法糖，「.」号和「:」号的区别在于，「:」号会在调用函数时，首先推入一个self，再推入函数的参数。</p><p>然后看看newInstance函数。它首先对obj进行或操作，确保传进来的obj不为空，保证其至少是一个空表。然后，就是为obj设置元表，设置为self，而self就是MyObject。接着就是为self设置一个属性__index，这个属性的值是一个function。和上面的setmetatable联合来看，这两句语句的意思是：<br>如果在obj中，根据一个key找到的结果是nil，那就去执行__index这个function。在这个function中，会去查找self这个表并返回，self就是MyObject。所以，如果我们访问obj的doSomething属性，因为obj没有，那就执行__index，在MyObject中查找，找到了，那就返回作查询结果。所以newInstance还有另一个版本：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject:newInstance</span><span class="params">( obj )</span></span></span><br><span class="line">    obj = obj <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    <span class="built_in">setmetatable</span>(obj, self)</span><br><span class="line">    self.<span class="built_in">__index</span> = self</span><br><span class="line">    obj.name = <span class="string">"Q"</span></span><br><span class="line">    obj.fieldB = <span class="string">"eat"</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br>更加的简化，意思是如果在obj中，根据的key到的结果是空，那就用这个key去self中查找，并作为查询结果。（这个版本我一开始无法理解，看了Lua的源码才知道是什么意思，还是function版的好理解..）</p><p>回到newInstance中，接下来就是为obj设置一些属性，然后返回。在doSomething中，因为我们执行的是<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oneObj:doSomething()</span><br></pre></td></tr></table></figure><br>所以在doSomething中，self就是oneObj。oneObj的name属性和doWhat属性是’Q’和’eat’，所以输出符合预期。</p><h1 id="3-函数式编程"><a href="#3-函数式编程" class="headerlink" title="3. 函数式编程"></a>3. 函数式编程</h1><p>Lua支持函数式编程。因为我之前更熟悉Java，转到Lua一时半会理解不了函数式编程。所以新的概念，我喜欢和Java比较。Lua中的函数式编程，就是把function看成是一个「值」，你可以在任意一个地方声明它，也可以把它赋值到某一个变量中。所以，只要把Lua中的函数当成一个值就好了，只不过这个值不能加减乘除和逻辑变换罢了。所以，下面的代码在Lua中是合法的：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> f = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'2333'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(f())</span><br><span class="line">    f = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'666'</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">print</span>(f())</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Output:</span></span><br><span class="line"><span class="comment">-- 2333</span></span><br><span class="line"><span class="comment">-- 666</span></span><br></pre></td></tr></table></figure></p><p>可以看到上面的代码，test中有嵌套了一个function。我在想，如果这个function访问了test的局部变量，那会是什么情形？做个实验：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIncreaser</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> level = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        level = level + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> level</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> increaser = getIncreaser()</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">5</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(increaser())</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Output:</span></span><br><span class="line"><span class="comment">-- 1</span></span><br><span class="line"><span class="comment">-- 2</span></span><br><span class="line"><span class="comment">-- 3</span></span><br><span class="line"><span class="comment">-- 4</span></span><br><span class="line"><span class="comment">-- 5</span></span><br></pre></td></tr></table></figure></p><p>讲道理，getIncreaser的level仅在getIncreaser的生命周期内有效。然后，getIncreaser返回的function中持有了level，所以在getIncreaser退出后，level并没有释放，因为increaser持有了它。所以每调用一次increaser，level就会自增一次，就是一个简单的自增器。这种现象，有一个很厉害的名字，叫做「闭包(Closure)」</p><p>简单的了解了函数式编程后，我继续和Java比较。Java中，回调函数怎么做？传一个函数？不行，因为Java不能把function作为参数。那就把这个function包装成一个类，再把这个类的实例作为参数就好了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Callback mCallback;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(Callback callback)</span> </span>&#123;</span><br><span class="line">        mCallback = callback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCallback.callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>好啰嗦啊，我只是要回调而已，如果是观察者模式，那我还要维护一个List。Lua支持函数式编程，那就只需这样：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCallback</span><span class="params">(callback)</span></span></span><br><span class="line">    myProcessor.callback = callback</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">notifyCallback</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> myProcessor.callback <span class="keyword">then</span></span><br><span class="line">        myProcessor.callback()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br>很简洁。如果是观察者模式，那就把callback插入到一个table就可以了，需要notify的时候遍历一下，挨个调用就好了。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><ol><li>table是Lua的一个数据结果，其行为类似于一个map。</li><li>metatable是对table操作时触发的行为的一个集合。</li><li>可以用table来实现function的默认参数。</li><li>运用table + metatable可以实现简单的OOP。</li><li>Lua支持函数式编程与闭包。</li></ol><h1 id="5-感想"><a href="#5-感想" class="headerlink" title="5. 感想"></a>5. 感想</h1><p>刚开始学Lua的时候，感觉它就是一个动态类型的语言。学完之后，觉得table很重要，只要精通table，我觉得就能精通Lua的七八成。另外，学了Lua之后，有了比较，才觉得Java有点啰嗦（非贬义，Java有他的道理），才能理解Kotlin中一些api为什么要这么设计，以及设计的理由是什么。虽然说技多不压身，但是学完之后一定要比较，我觉得才能理解作者设计某一门语言的理由，它适用于什么情况，不适用于什么情况。有了比较，才能更好地使用一门语言，写出更好的代码，因为编程是一门艺术。没有比较，我觉得学再多也没用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h1&gt;&lt;p&gt;最近学习了Lua语言，记录一下自己觉得对几个重要概念的学习过程。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018年度总结</title>
    <link href="www.zspirytus.com/theSummaryOf2018/"/>
    <id>www.zspirytus.com/theSummaryOf2018/</id>
    <published>2018-12-31T03:56:42.000Z</published>
    <updated>2018-12-31T06:36:58.087Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://cn.bing.com/az/hprichbg/rb/EyeFireworks_ZH-CN1712859531_1920x1080.jpg" alt="cover"></p><p>时光如梭，转眼2018年的最后一天已经到来，过了今天就是2019年了，就总结一下吧。</p><a id="more"></a><p>上半年基本上都是咸鱼的状态，忙第一学位的课程，忙第二学位的课程，周一到周日基本天天满课，技术的学习与学位的取舍，我选择了学位，毕竟做好现阶段最重要的工作还是很重要的，所以上半年就放松了技术的学习，看我的GitHub的Contribution就知道啦。<br><img src="/theSummaryOf2018/mGitHub.png" title="githubContribution"></p><p>重要的事情都发生在下半年，我也开始思考。</p><p>关于实习，在不对的时候做该做的事。<br>6月份那会儿，人生的第一次面试，很失败，只能怪我太菜。这次面试刷新了我对技术的认识，我开始认真的思考了我的不足，以及我的优势。知耻而后勇，暑假期间，白天上课，网上看书练习，多给自己的GitHub上传代码，技术也慢慢上来了。8月下旬，第二次面试顺利通过，并在8月23号入职。实习期间我见识到了很多我之前没见识到的东西。那段时间，可能是接收了新事物，看问题的方式变了，我也开始思考我的出路。因为秋招临近，我的重心转移到了秋招，因此实习没一个月就辞了，至今还是觉得很抱歉，浪费了公司的时间和精力。秋招期间，我也分出一部分精力在寻找实习上，面过爱奇艺，字节跳动。菜是一方面，没认真准备也是一方面，虽然面试都聊得很不错，当最终都挂了。数了数，找实习而面试的次数也就五次吧。</p><p>关于秋招，从否定自己到肯定自己。<br>9月份秋招季，我也加入了秋招大军。听说是互联网寒冬，初生牛犊不怕虎，我投了6家大型互联网公司。最终进了一家，算是运气好吧。我投的6家公司，除了现在进的这一家，无一例外全部都挂在了笔试上。我认真的思考了原因，发现是算法的原因，于是乎我在LeetCode上注册了一个账号，开始刷题。刷了50来道题的样子就过了笔试，然后面试就是一路绿灯，顺利的拿下第一份工作，2018年的第一个目标达成了，嘿嘿。还有一家是在深圳的互联网金融公司，但是由于个人原因，在终面HR面我选择了放弃。总的来说，秋招前，说实话我是没有信心的，但是找到工作后，我发现我多少还有有一点点优势的。</p><p>关于学位，平淡的走完大部分该走的程序。<br>第一学位，计算机科学与技术和金融学，我能做的事都做了，也平淡的过去了，目前还在构思第二学位的开题报告。</p><p>关于技术，慢慢的进步。<br>在人生的第一次面试后，我决定开这个博客，有输入才能有输出，同时输出还能倒逼输入，这是一个正反馈的过程，对我的技术学习很有帮助。博客的更新，我基本保持一月一更，因此有稳定的输入和输出，技术也开始慢慢的进步。有时候百度不到的东西，不得不到某404网站找，读过官方文档，StackOverflow的问答，读过世界顶尖大学的课件和论文，也读过外国的博客，慢慢的开始习惯全英的学习资料，也慢慢的从百度转移到了某404网站上。和2018年年初的我对比，技术上可以说是全方位的碾压了。2018年的第二个目标也达成了~~ 另外值得一提的是，校招实习真的让我学到了很多，Kotlin的函数式编程、代码的抽象思想、设计模式的合理运用、自动化构建等等，很多都是我之前不能独自触及到的领域，静下心来，好好消化吧。</p><p>关于不足的方面，学习和生活没有好好的平衡。<br>自从第一次面试后，我开始追赶。可能是心里的好胜的心态，不想输给自己，疯狂的看书，练习，写代码。晚上经常熬夜到很晚，有几次，连续一周多，每天晚上写代码到4点，第二天11点起床继续，忙的饭都忘了吃，啃点面包继续。饮食不规律+熬夜，熬不住，也就顺利的发烧了。后来发现这样不行，开始矫正，生物钟也回到正常状态。虽然如此，但我还是很难把握学习与生活之间的平衡点，所以在2019年还是要好好把握这个平衡点。</p><p>展望：<br>2019年最重要的目标，就是好好工作，好好生活，好好学习。如果还能完成其他目标，那就是锦上添花啦。就这样吧，新年快乐。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://cn.bing.com/az/hprichbg/rb/EyeFireworks_ZH-CN1712859531_1920x1080.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;时光如梭，转眼2018年的最后一天已经到来，过了今天就是2019年了，就总结一下吧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记一次AIDL的学习与实践</title>
    <link href="www.zspirytus.com/aidlInAndroid/"/>
    <id>www.zspirytus.com/aidlInAndroid/</id>
    <published>2018-11-25T06:36:12.000Z</published>
    <updated>2018-11-26T15:30:01.878Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/aidlInAndroid/aidlInAndroid_cover.jpg" alt="cover"></p><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>终于考完试了hhh，终于有时间更新博客了。正好之前自学跨进程编程，写个博文记录一下。</p><a id="more"></a><h2 id="2-Android中的多进程"><a href="#2-Android中的多进程" class="headerlink" title="2. Android中的多进程"></a>2. Android中的多进程</h2><p>在Android中，默认情况下，应用中的组件是运行在同一个进程的。我们可以在AndroidManifest.xml中使用<code>android:process</code>属性来为四大组件指定运行的进程。比如对于Service：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">":playMusicProcess"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><br>当然也可以通过JNI，在C/C++代码中调用fork()来开启进程，这里不讨论这种情况。</p><p>然而，好端端的为什么要使用多进程？因为多进程相较于单进程是有好处的。<br>首先，多进程意味着更多内存空间，OOM的概率更小。DVM会给每个进程分配固定的空间。多进程意味着会被分配更多空间，因此合理利用多进程，能够减少OOM发生的概率。<br>其次，像一些功能，相对独立，只需要在后台运行，那我们可以让它运行在另一个进程中的Service，即使UI进程被杀了，这个模块也能正常运行。</p><p>接下来看看多进程的实现，我使用AIDL来进行进程间的通信。</p><h2 id="3-准备知识：序列化"><a href="#3-准备知识：序列化" class="headerlink" title="3. 准备知识：序列化"></a>3. 准备知识：序列化</h2><p>在跨进程通信中，从一个进程发送消息到另一个进程时，会先把消息进行序列化，通过Binder传给另一个进程，另一个进程再通过反序列化以获得消息。所以在实现跨进程通信之前，我们需要对序列化有一定的了解。<br>在Android开发中我们有两种序列化方案：<code>Serializable接口</code>和<code>Parcelable接口</code>。前者是Java自带的，后者是为Android系统量身打造的。两者各有优劣：<br><code>Serializable接口</code>使用方便，但是性能开销较大，涉及大量I/O操作。<br><code>Parcelable接口</code>性能开销小，但使用较为复杂。<br>基于性能优先的原则，我优先使用的是<code>Parcelable接口</code>。</p><p>对于一个实体类Music，我们让它实现Parcelable接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String mMusicName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mMusicDuration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Music</span><span class="params">(String musicName, <span class="keyword">long</span> musicDuration)</span> </span>&#123;</span><br><span class="line">        mMusicName = musicName;</span><br><span class="line">        mMusicDuration = musicDuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Music</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">        mMusicName = source.readString();</span><br><span class="line">        mMusicDuration = source.readLong();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMusicName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> musicName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMusicDuration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> musicDuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeString(mMusicName);</span><br><span class="line">        dest.writeLong(mMusicDuration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Music&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Music&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Music <span class="title">createFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Music(source);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Music[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Music[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现Parcelable接口，需要定义一个CREATOR变量，并实现方法<code>describeContents()</code>和<code>writeToParcel()</code>。<br>对于变量<code>CREATOR</code>，它是Parcelable.Creator&lt;T>接口一个实现的对象。其中，<code>createFromParcel()</code>是用来反序列化出一个对象，<code>newArray()</code>是用来反序列化出一个对象的数组。这里只需要返回一个空数组即可。<br>对于方法<code>describeContents()</code>，它返回对象内容的描述，如果内容中有文件描述符(File Descriptor, fd)就返回1，否则返回0。这里返回0。<br>对于方法<code>writeToParcel()</code>，它在序列化的时候被调用。在这里面序列化需要序列化的变量。<br><blockquote><p>踩坑点： 在<code>writeToParcel</code>按ABCD的顺序序列化，在反序列化的时候也一定要按照ABCD的顺序反序列化。否则会反序列化出一个不正确的对象。</p></blockquote></p><p>序列化的一些注意点就基本这样。</p><h2 id="4-关于AIDL"><a href="#4-关于AIDL" class="headerlink" title="4. 关于AIDL"></a>4. 关于AIDL</h2><p>AIDL是Android接口定义语言(Android Interface Definition Language, AIDL)，用于规定进程间通信的方式(这里我理解为进程间的通信协议)。<br>它和Java的接口是有些许不同的：</p><ol><li>AIDL不支持定义静态变量，仅支持定义方法。</li><li>AIDL仅支持有限的数据类型：<ul><li>基本数据类型：int, long, char, boolean, double等</li><li>String和CharSequence</li><li>List，仅支持ArrayList，且里面的数据必须是AIDL支持的数据类型</li><li>Map，仅支持HashMap，不支持带泛型参数的Map(<a href="http://wing-linux.sourceforge.net/guide/developing/tools/aidl.html#aidlsyntax" target="_blank" rel="noopener">参考</a>)</li><li>Parcelable，支持所有实现了Parcelable接口的对象</li><li>AIDL，支持AIDL接口对象</li></ul></li></ol><blockquote><p>踩坑点： 在方法的参数列表中，除了基本类型和AIDL接口外，都需要标注方向in, out, inout<br>in代表数据只能从客户端流向服务端，即客户端 -&gt; 服务端<br>out代表数据只能从服务端流向客户端，即客户端 &lt;- 服务端<br>inout代表数据可以在客户端和服务端之间双向流动，即客户端 <-> 服务端</-></p></blockquote><p>另外，Parcelable对象需要在aidl中显式的声明和import<br>如果实体Music.java位于java文件夹中的包com.example.exampleproject.entity包下，那就需要在aidl文件夹中的包com.example.exampleproject.entity下声明Music.aidl，内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Music.aidl</span><br><span class="line">package com.example.exampleproject.entity;</span><br><span class="line"></span><br><span class="line">parcelable Music;</span><br></pre></td></tr></table></figure><br>然后在需要用到Music的AIDL文件中显式import出来，无论同不同包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import com.example.exampleproject.entity.Music;</span><br></pre></td></tr></table></figure></p><blockquote><p>如果你用Android Studio来编写AIDL文件，那你就暂时把AS当成文本编辑器吧，不要指望它会帮你代码补全，自动import相关包…</p></blockquote><p>所以，一个正确的AIDL文件是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// ITest.aidl</span><br><span class="line">package com.example.exampleproject;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import com.example.exampleproject.entity.Music;</span><br><span class="line"></span><br><span class="line">interface ITest&#123;</span><br><span class="line">    </span><br><span class="line">    void setMusic(in Music music);</span><br><span class="line">    void setMap(in Map map);</span><br><span class="line">    void setList(in List&lt;Music&gt; musicList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-使用AIDL开启多进程模式"><a href="#5-使用AIDL开启多进程模式" class="headerlink" title="5. 使用AIDL开启多进程模式"></a>5. 使用AIDL开启多进程模式</h2><p>好了，我们已经明白了AIDL的正确书写方法，接下来使用AIDL来实现进程间的通信。这里以双向通信为例子：Activity传一个int型的值给Service，Service处理后返回给Activity。<br>这里的Activity，我们取名为MainActivity，Service我们取名为MyService。<br>ok，既然是处理后返回，所以MainActivity中需要有一个回调接口来给MyService回调，但是AIDL不支持普通接口，但支持AIDL接口，因此，我们就用AIDL来声明MainActivity中的回调接口：<br><figure class="highlight plain"><figcaption><span>ICallback.aidl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.zspirytus.simpleaidltest;</span><br><span class="line"></span><br><span class="line">interface ICallback &#123;</span><br><span class="line">    void callback(int a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Activity和Service之间的通信是通过Binder来实现的，而AIDL接口的内部类<code>Stub</code>的实现也是一个Binder，因为它继承了<code>android.os.Binder</code>接口，因此我们可以在AIDL接口中规定MainActivity和MyService的通信方式。由于我们需要从MainActivity中传值给MyService，并且要给MyService设置MainActivity的回调接口。因此就有：<br><figure class="highlight plain"><figcaption><span>IAIDLTest.aidl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.zspirytus.simpleaidltest;</span><br><span class="line"></span><br><span class="line">import com.zspirytus.simpleaidltest.ICallback;</span><br><span class="line"></span><br><span class="line">interface IAIDLTest &#123;</span><br><span class="line">    void testMethod(int a);</span><br><span class="line">    void setCallback(ICallback callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>testMethod()</code>是MainActivity向MyService传值的方法<br><code>setCallback()</code>是MainActivity为MyService设置回调接口的方法。</p><p>MainActivity和MyService通信的桥梁已经规定好了，接下来就是实现它。我们在MyService中定义一个内部类MyBinder来实现它：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ICallback mCallback;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBinder</span> <span class="keyword">extends</span> <span class="title">IAIDLTest</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            Log.e(<span class="keyword">this</span>.getClass().getSimpleName(), <span class="string">"MyService Receive Msg: "</span> + a + <span class="string">"\t at Thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>)</span><br><span class="line">                mCallback.callback(a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(ICallback callback)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            mCallback = callback;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单解释一下，MainActivity通过<code>setCallback()</code>为MyService设置回调接口，当MainActivity通过<code>testMethod()</code>传值给MyService时，MyService会处理传过来的值(这里以打印日志代替)，然后检查一下回调接口是否为空。如果不为空则调用它的回调方法，进而通知MainActivity。<br><blockquote><p>如果提示找不到IAIDLTest，可以尝试Clean一下Project尝试解决，如果Gradle报错，请检查AIDL文件是否正确。</p></blockquote></p><p>然后补充一下MyService的生命周期，服务端就大功告成了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyBinder mBinder;</span><br><span class="line">    <span class="keyword">private</span> ICallback mCallback;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mBinder == <span class="keyword">null</span>)</span><br><span class="line">            mBinder = <span class="keyword">new</span> MyBinder();</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBinder</span> <span class="keyword">extends</span> <span class="title">IAIDLTest</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            Log.e(<span class="keyword">this</span>.getClass().getSimpleName(), <span class="string">"MyService Receive Msg: "</span> + a + <span class="string">"\t at Thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>)</span><br><span class="line">                mCallback.callback(a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(ICallback callback)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            mCallback = callback;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务端已经解决了，现在来看客户端MainActivity。<br>Activity和Service之间的通信可以通过Activity绑定Service的形式来实现，多进程模式下也不例外，但有些许不同。<br>首先声明一个Binder来构建MainActivity与MyService通信的桥梁：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IAIDLTest mBinder;</span><br></pre></td></tr></table></figure><br>然后以内部类的形式实现MyService回调MainActivity的回调接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ICallbackImpl</span> <span class="keyword">extends</span> <span class="title">ICallback</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> a)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                a1();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                a2();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">a1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mRemoteMsg.setText(<span class="string">"Receive From Remote Service: a = 1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">a2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mRemoteMsg.setText(<span class="string">"Receive From Remote Service: a = 2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其次创建一个<code>ServiceConnection</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">conn = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> </span>&#123;</span><br><span class="line">        mBinder = IAIDLTest.Stub.asInterface(iBinder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mBinder.setCallback(mCallback);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> </span>&#123;</span><br><span class="line">        mBinder = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>最后在适当生命周期绑定和解绑Service:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">    bindService();</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    ... ...</span><br><span class="line">    unbindService();</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Intent startServiceIntent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, MyService.class);</span><br><span class="line">    bindService(startServiceIntent, conn, BIND_AUTO_CREATE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unbindService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unbindService(conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在适当的时候发送请求就可以了，比如单击按钮发送请求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    findViewById(R.id.btn).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mBinder.testMethod(A);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，毕竟是跨进程通信，当前进程下发起远程请求的线程是会被挂起的。如果发起的请求是一个耗时操作，并且是UI线程发起的，那就会有ANR的风险。因此，安全起见，在发起跨进程请求时，推荐切换到另一个线程后再发起。所以上面的程序可以这么改进：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mBinder.testMethod(A);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.setName(<span class="string">"myThread"</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后呢，等到服务端把请求执行完毕后，客户端发起请求的线程会被唤醒，然后继续执行。所以我们不能在回调方法中执行UI更新操作，因为回调方法并不在UI线程中执行(前面在非UI线程中发起请求)。如果需要更新UI，需要切换到UI线程后再更新UI。所以需要如下改进：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ICallbackImpl</span> <span class="keyword">extends</span> <span class="title">ICallback</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> a)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        mRemoteMsg.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        a1();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        a2();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此，即使服务端执行耗时操作，界面也不会卡死：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    SystemClock.sleep(<span class="number">5000</span>);</span><br><span class="line">    Log.e(<span class="keyword">this</span>.getClass().getSimpleName(), <span class="string">"MyService Receive Msg: "</span> + a + <span class="string">"\t at Thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>)</span><br><span class="line">    mCallback.callback(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>服务端的方法会在Binder线程池中的线程运行，因此不必担心主线程会被阻塞</p></blockquote><p>还有一个小问题，如果已经绑定的Service意外死亡怎么办（比如说被系统杀死了）？我们只需要在<code>ServiceConnect#onServiceDisconnected()</code>中重新连接服务即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> </span>&#123;</span><br><span class="line">    bindService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><blockquote><p>MyService被杀死也没关系，<code>MainActivity#bindService()</code>中在绑定MyService时，flag已经被设置为BIND_AUTO_CREATE，会重新启动MyService的。</p></blockquote><br>由于代码太长，我没有全放，只放一些比较关键的，完整代码可以看<a href="https://github.com/zkw012300/SampleCodeRepo/tree/master/simpleaidltest" target="_blank" rel="noopener">这里</a></p><p>好了，简单进程间通信的实现就完成了，总结一下，基本步骤：</p><ol><li>创建AIDL文件搭建客户端和服务端的沟通桥梁</li><li>服务端实现AIDL接口</li><li>客户端通过ServiceConnection#onServiceConnected()获取Binder对象</li><li>在ServiceConnection#onServiceDisconnected()中重新连接，防止Service意外死亡</li><li>在客户端使用Binder对象在适当的线程向服务端发送请求</li><li>在客户端的适当线程中回调</li></ol><h2 id="6-实践-简单的音乐播放器实现"><a href="#6-实践-简单的音乐播放器实现" class="headerlink" title="6. 实践 - 简单的音乐播放器实现"></a>6. 实践 - 简单的音乐播放器实现</h2><p>明白了进程间通讯的流程，接下来我们来实现一个简单的音乐播放功能吧。<br>我们需要完成：</p><ol><li>Activity和Service在不同进程</li><li>默认进程中的Activity控制音乐播放暂停，接收来自另一个进程的Service发送的播放进度并显示</li><li>另一个进程的Service负责播放音乐，发送播放进度给Activity。</li></ol><p>这个音乐播放器，至少要能播放、暂停、显示播放进度。我们可以把播放暂停和显示播放进度这两个功能分离，分别管理。<br>对于播放暂停，只需要简单的定义两个方法<code>play()</code>和<code>pause()</code>即可：<br><figure class="highlight plain"><figcaption><span>IPlayControl.aidl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// IPlayControl.aidl</span><br><span class="line">package com.zspirytus.simplemusicplayer;</span><br><span class="line"></span><br><span class="line">import com.zspirytus.simplemusicplayer.entity.Music;</span><br><span class="line"></span><br><span class="line">interface IPlayControl &#123;</span><br><span class="line">    void play(in Music music);</span><br><span class="line">    void pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于获取播放进度的问题，我们采取订阅 - 发布的模式，需要获取播放进度的对象，传一个回调接口给被观察者，即服务端。<br>以下分别是订阅取消订阅和回调接口的AIDL文件：<br><figure class="highlight plain"><figcaption><span>IPlayProgressRegister.aidl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// IPlayProgressRegister.aidl</span><br><span class="line">package com.zspirytus.simplemusicplayer;</span><br><span class="line"></span><br><span class="line">import com.zspirytus.simplemusicplayer.IOnProgressChange;</span><br><span class="line"></span><br><span class="line">interface IPlayProgressRegister &#123;</span><br><span class="line">    void registerProgressObserver(IOnProgressChange observer);</span><br><span class="line">    void unregisterProgressObserver(IOnProgressChange observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><figcaption><span>IOnProgressChange.aidl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// IOnProgressChange.aidl</span><br><span class="line">package com.zspirytus.simplemusicplayer;</span><br><span class="line"></span><br><span class="line">interface IOnProgressChange &#123;</span><br><span class="line">    void onProgressChange(int seconds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，就要实现服务端了。但是，前面音乐播放控制功能和进度获取功能已经被我分离了，换言之，就是有两个Binder。但是一个Service只能有一个Binder和外界沟通啊？怎么解决？不如我们定义一个Binder连接池，根据适当的请求码binderCode来返回对应的Binder。这个Binder连接池能被客户端拿到，所以它应该由AIDL实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// IBinderPool.aidl</span><br><span class="line">package com.zspirytus.simplemusicplayer;</span><br><span class="line"></span><br><span class="line">interface IBinderPool &#123;</span><br><span class="line">    IBinder getBinder(int binderCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Binder连接池已经定义好了，接下来就是实现服务端了，同样的，我还是用内部类的方式实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayMusicService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PLAY_CONTROL_BINDER = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PLAY_PROGRESS_REGISTER_BINDER = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BinderPool mBinder;</span><br><span class="line">    <span class="keyword">private</span> PlayControl mPlayControl;</span><br><span class="line">    <span class="keyword">private</span> PlayProgressRegister mPlayProgressRegister;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RemoteCallbackList&lt;IOnProgressChange&gt; mIOnProgressChangeList = <span class="keyword">new</span> RemoteCallbackList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderPool</span> <span class="keyword">extends</span> <span class="title">IBinderPool</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> IBinder <span class="title">getBinder</span><span class="params">(<span class="keyword">int</span> binderCode)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (binderCode) &#123;</span><br><span class="line">                <span class="keyword">case</span> PLAY_CONTROL_BINDER:</span><br><span class="line">                    <span class="keyword">if</span> (mPlayControl == <span class="keyword">null</span>)</span><br><span class="line">                        mPlayControl = <span class="keyword">new</span> PlayControl();</span><br><span class="line">                    <span class="keyword">return</span> mPlayControl;</span><br><span class="line">                <span class="keyword">case</span> PLAY_PROGRESS_REGISTER_BINDER:</span><br><span class="line">                    <span class="keyword">if</span> (mPlayProgressRegister == <span class="keyword">null</span>)</span><br><span class="line">                        mPlayProgressRegister = <span class="keyword">new</span> PlayProgressRegister();</span><br><span class="line">                    <span class="keyword">return</span> mPlayProgressRegister;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayControl</span> <span class="keyword">extends</span> <span class="title">IPlayControl</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Music music)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            MyMediaPlayer.getInstance().play(music);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            MyMediaPlayer.getInstance().pause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayProgressRegister</span> <span class="keyword">extends</span> <span class="title">IPlayProgressRegister</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerProgressObserver</span><span class="params">(IOnProgressChange observer)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            mIOnProgressChangeList.register(observer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterProgressObserver</span><span class="params">(IOnProgressChange observer)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            mIOnProgressChangeList.unregister(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在IBinderPool.Stub的实现BinderPool中，会根据传递过来的binderCode来返回对应的已被实例化的Binder。<br><code>MyMediaPlayer</code>是我对MediaPlayer的一个很简单的封装，拿来当例子够了。<br>接下来补上Service的生命周期就ok了，代码比较长，我就不贴了。</p><p>接下来看客户端的实现：<br>首先定义从Service端获得的Binder对象，然后在ServiceConnection中获取Binder和重连Service。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IBinderPool mBinder;</span><br><span class="line"><span class="keyword">private</span> ServiceConnection conn;</span><br><span class="line"></span><br><span class="line">conn = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> </span>&#123;</span><br><span class="line">        mBinder = IBinderPool.Stub.asInterface(iBinder);</span><br><span class="line">        register();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> </span>&#123;</span><br><span class="line">        bindService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接着，实现回调接口并传给Service，以供其传递播放进度给Activity（上一个步骤的<code>register()</code>方法已经把回调接口传给了Service）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">IOnProgressChangeImpl</span> <span class="keyword">extends</span> <span class="title">IOnProgressChange</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProgressChange</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> currentMilliseconds)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        mProgressText.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mProgressText.setText(DateUtil.getMinutesSeconds(currentMilliseconds));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后就是请求部分，在客户端中，我们获得是Binder连接池的对象，我们可以传binderCode来获得对应的Binder:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PLAY_CONTROL_BINDER = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PLAY_PROGRESS_REGISTER_BINDER = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Music sampleMusic = MusicFactory.getSampleMusic();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mPlayControl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    IBinder iBinder = mBinder.getBinder(PLAY_CONTROL_BINDER);</span><br><span class="line">                    mPlayControl = IPlayControl.Stub.asInterface(iBinder);</span><br><span class="line">                &#125;</span><br><span class="line">                mPlayControl.play(sampleMusic);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mPlayControl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    IBinder iBinder = mBinder.getBinder(PLAY_CONTROL_BINDER);</span><br><span class="line">                    mPlayControl = IPlayControl.Stub.asInterface(iBinder);</span><br><span class="line">                &#125;</span><br><span class="line">                mPlayControl.pause();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后在AndroidManifest.xml中为Service指定进程，就大功告成了。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.zspirytus.simplemusicplayer.PlayMusicService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">":playMusicService"</span>&gt;</span><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>由于代码太长，我没有全放，只放一些比较关键的，完整代码可以看<a href="https://github.com/zkw012300/SampleCodeRepo/tree/master/simplemusicplayer" target="_blank" rel="noopener">这里</a>。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>我目前的理解是，在Android跨进程通讯中，一般是序列化+接口+线程切换。只要注意这三点一般没大问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/aidlInAndroid/aidlInAndroid_cover.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;终于考完试了hhh，终于有时间更新博客了。正好之前自学跨进程编程，写个博文记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="www.zspirytus.com/tags/Android/"/>
    
      <category term="多进程" scheme="www.zspirytus.com/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>关于深度优先搜索的一点小心得</title>
    <link href="www.zspirytus.com/DFS/"/>
    <id>www.zspirytus.com/DFS/</id>
    <published>2018-10-18T02:32:07.000Z</published>
    <updated>2018-11-08T16:22:45.010Z</updated>
    
    <content type="html"><![CDATA[<img src="/DFS/cover.jpeg"><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>上周刷了20来道LeetCode的题，总结出了一些关于深度优先搜索的小小的心得，于是有了这篇博客。这次的总体思路是：</p><ol><li>深度优先搜索算法的工作过程</li><li>如何使用深度优先搜索算法来进行遍历</li><li>两个有趣的问题</li><li>深度优先搜索算法和循环的关系</li></ol><p>那我们开始吧。</p><a id="more"></a><h2 id="2-深度优先搜索"><a href="#2-深度优先搜索" class="headerlink" title="2. 深度优先搜索"></a>2. 深度优先搜索</h2><p>深度优先搜索（Deep First Search, DFS）是一种先序遍历，先遇到的节点先访问，然后以这个节点为起点，继续向下遍历，直至所有的节点都被访问（连通分量 == 1的情况下）。所以，个人认为，DFS可以看做是一种暴力枚举的算法。多说无益，下面一个例子可能会让你对DFS有初步的了解。<br><img src="/DFS/SimpleExample.jpg" title="简单的例子"><br>这是一个有向、无环、连通分量为1的图，我们可以用邻接矩阵来存储它：<br><img src="/DFS/AdjacencyMatrix.jpg" title="邻接矩阵"><br>这个矩阵的意义是，如果<code>graph[i][j] == 1</code>，那么节点i和节点j的关系是<code>i -&gt; j</code>，即有从节点i到节点j的通路。<br>我先不放代码，我先跟着DFS的思路来对上面的图，以节点1为起点深度优先遍历一次。<br>由于是从节点1开始遍历，因此我们先看看数组graph[0][0…5]，从0到5扫一遍，发现graph[0][1]不为零，说明有节点1到节点2的边。由于DFS是先访问，再以此节点为起点继续向下遍历，所以我们先把节点1，节点2存起来，然后以节点2为起点，向下遍历，如下图：<br><img src="/DFS/SimpleExample_Step1.jpg" title="DFS第一步"><br>接下来，扫一遍<code>graph[1][0...5]</code>，发现<code>graph[1][2]</code>不为0，说明节点2连向节点3，则把节点3存起来，然后以节点3为起点，向下遍历：<br><img src="/DFS/SimpleExample_Step2.jpg" title="DFS第二步"><br>很好，接下来扫一遍<code>graph[2][0...5]</code>，但是遗憾的是，数组<code>graph[2][0...5]</code>并没有值为1的元素，这表明，节点3没有连向其他节点，即出度为0。因此，这时候需要回溯，回到上一层：<br><img src="/DFS/SimpleExample_Step3.jpg" title="DFS第三步"><br>这时，上一步已经回溯到了上一层，此时我们需要扫描<code>graph[1][3...5]</code>，此时发现<code>graph[1][3]</code>不为0，说明节点2连向节点4，那么应该把节点4存起来，接下来以节点4为起点继续向下遍历：<br><img src="/DFS/SimpleExample_Step4.jpg" title="DFS第四步"><br>很好，接下来扫一遍<code>graph[3][0...5]</code>，发现<code>graph[3][4]</code>不为0，说明节点4连向节点5，我们应该把节点5存起来，然后以节点5为起点，向下遍历：<br><img src="/DFS/SimpleExample_Step5.jpg" title="DFS第五步"><br>此时，我们需要扫描一遍<code>graph[4][0...5]</code>，发现<code>graph[4][5]</code>不为0，说明节点5连向节点6，我们应该把节点6存起来。然后以节点6位节点，向下遍历：<br><img src="/DFS/SimpleExample_Step6.jpg" title="DFS第六步"><br>然而，<code>graph[5][0...5]</code>并没有不为0的元素，这说明，节点6的出度为0，应该回溯，回到上一层：<br><img src="/DFS/SimpleExample_Step7.jpg" title="DFS第七步"><br>此时，我们回到了<code>graph[4][0...5]</code>，但是<code>graph[4][0...5]</code>已经扫完了，我们继续回溯，回到<code>graph[4][0...5]</code>的上一层<code>graph[3][5...5]</code>，但是<code>graph[3][5...5]</code>已经没有不为0的元素了，所以我们继续回溯，回到上一层：<br><img src="/DFS/SimpleExample_Step8.jpg" title="DFS第八步"><br>此时，我们回到了<code>graph[1][4...5]</code>，<code>graph[1][4...5]</code>已经没有不为0的元素了，继续回溯，回到上一层：<br><img src="/DFS/SimpleExample_Step9.jpg" title="DFS第九步"><br>终于回到<code>graph[0][2...5]</code>了，我们继续扫描，发现<code>graph[0][4]</code>不为0，但是节点5（<code>graph[0][4]</code>的4表示节点5）已经访问过了，我们没必要，也不能继续存节点5了，所以我们忽略<code>graph[0][4]</code>，继续扫描，最后扫描完毕，遍历结束。<br><img src="/DFS/SimpleExample_Step10.jpg" title="DFS第十步"></p><p>这个过程如果明白了，代码就很容易写出来：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deepFirstSearch</span><span class="params">(<span class="keyword">int</span>[][] graph, List&lt;Integer&gt; result, <span class="keyword">int</span>[] accessFlag, <span class="keyword">int</span> startVertex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startVertex &lt; graph.length) &#123;</span><br><span class="line">        result.add(startVertex + <span class="number">1</span>);</span><br><span class="line">        accessFlag[startVertex] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[startVertex].length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[startVertex][i] == <span class="number">1</span> &amp;&amp; accessFlag[i] != <span class="number">1</span>) &#123;</span><br><span class="line">                deepFirstSearch(graph, result, accessFlag, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>解释一下，for循环对应上面所说的扫描，<code>startVertex</code>是当前的起点。如果<code>graph[startVertex][i]</code>不为0，说明有从startVertex到i的通路，即<code>startVertex -&gt; i</code>，并且如果节点i并未被访问（访问节点i时accessFlag[i]会被置为1），那就以节点i为起点向下遍历；而if语句是为了检查输入数据是否合法。<br>方法已经写好，我们只需要如下调用，就能拿到DFS的结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">deepFirstSearch(graph, result, <span class="keyword">new</span> <span class="keyword">int</span>[graph.length], <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>总结一下，DFS就是先遇到先访问，再以此为起点继续访问，直至全部访问完毕，很像先序遍历。</p><h2 id="3-DFS应该怎么用来遍历？"><a href="#3-DFS应该怎么用来遍历？" class="headerlink" title="3. DFS应该怎么用来遍历？"></a>3. DFS应该怎么用来遍历？</h2><p>通过上面的说明，想必已经对DFS有初步的理解了吧。那我们继续吧。<br>前面我已经说过，DFS可以看做是一种暴力枚举算法。结合上面的例子，我们可以看到，邻接矩阵graph的所有元素都被DFS算法扫描了一遍，所以至少从这个例子来看DFS是一种暴力枚举算法。我认为确实也是。<br>OK，既然我们已经知道DFS可以看做一种暴力枚举算法，我们应该怎么用它来枚举？在这里，我想通过分析二叉树的先序遍历过程乃至多叉树的遍历过程，进而推广到一般的情况来说明。</p><p>首先定义一下树的数据结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Tree leftChild;</span><br><span class="line">    Tree rightChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>自然地，该二叉树的先序遍历就可以这么写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderTraversal</span><span class="params">(Tree parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="keyword">null</span>) &#123;</span><br><span class="line">        accessTreeVertex(parent);</span><br><span class="line">        preOrderTraversal(parent.leftChild);</span><br><span class="line">        preOrderTraversal(parent.rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>二叉树的遍历如何推广到多叉树的遍历？如果可以用for循环将这个节点的所有孩子节点列举出来那就好了。确实可以。我们只需要稍微改写一下数据结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Tree children[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后如下遍历：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderTraversal</span><span class="params">(Tree parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="keyword">null</span>) &#123;</span><br><span class="line">        accessTreeVertex(parent);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parent.children.length; i++) &#123;</span><br><span class="line">            preOrderTraversal(tree.children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为什么要这么写，这段代码背后的思路是什么？<br>如果<code>children.length == 2</code>那就是二叉树的情形。自然地，如果<code>children.length</code>为任意值，那就是任意多叉树的情形，即可以对任意多叉树进行遍历。其实思路就是将孩子节点转化成可以被for循环列举的形式（如上面是把孩子节点转成数组）。<br>现在，我们看看多叉树的子结构：<br><img src="/DFS/APartOfTree.jpg" title="多叉树子结构"><br>这个多叉树的子结构，是一个父节点带着n个子节点(n是任意一个大于0的整数)的结构。我们如何对这个子结构进行遍历？</p><ol><li>首先我们访问父节点，即<code>accessVertex(parent)</code></li><li>因为父节点有n个子节点，所以我们挨个的访问它们。由于孩子节点存在数组中，于是我们可以用for循环解决。</li></ol><p>因此遍历一个子结构就可以这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// traversal the substructure of tree</span><br><span class="line">// Input: SubStructure of tree</span><br><span class="line"></span><br><span class="line">function traversalSubStructure(Tree subTreeRoot):</span><br><span class="line">    access(subTreeRoot)</span><br><span class="line">    for i in 0 to subTreeRoot.children.length</span><br><span class="line">        traversalSubStructure(subTreeRoot.children[i])</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>由于多叉树所有的子结构共同组成整个多叉树（即可以被递归定义），所以我们可以用递归来完成遍历。<br>如何使用递归？只需要确认好边界条件即可。初始条件当然是放入一个树的根，停止向下递归则是遇到了叶子节点，即这个节点的children域为空。所以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Traversal tree</span><br><span class="line">// Input: root of tree</span><br><span class="line"></span><br><span class="line">function traversalTree(Tree treeRoot):</span><br><span class="line">    if treeRoot not null then</span><br><span class="line">        access(treeRoot)</span><br><span class="line">        for i in 0 to treeRoot.children.length</span><br><span class="line">            traversalSubStructure(treeRoot.children[i])</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>说了那么多，我想表达的是：如果一个节点，它的子节点可以用循环来列举的话，那我们可以用循环+递归的形式来进行遍历这个图。<br>更近一步来说，我们可以用递归+一个for循环来实现n重循环，进而进行遍历。n重循环天生就适合拿来作为枚举的工具。所以，我们可以把问题写成n重循环的形式，然后再转化成递归，就可以用DFS来解决遍历问题。<br>因此，DFS可以写成如下形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void DFS(Graph graph) &#123;</span><br><span class="line">    if(边界条件) &#123;</span><br><span class="line">        for(i;循环条件;i++) &#123;</span><br><span class="line">        DFS(graph.child.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-两个问题"><a href="#4-两个问题" class="headerlink" title="4. 两个问题"></a>4. 两个问题</h2><p>在刷题的过程中，我遇到了两个很有意思的问题，都可以用DFS来解决，这里分享一下，分别是迷宫问题和不重复字符的字符串。</p><h3 id="4-1-迷宫问题"><a href="#4-1-迷宫问题" class="headerlink" title="4.1. 迷宫问题"></a>4.1. 迷宫问题</h3><p>长话短说，迷宫问题是这么被描述的（LeetCode上的描述很长，我就不贴了）：<br>给定一个二维数组来表示一个迷宫。这个数组里的元素要么为0要么为1；0代表可以通过，1代表是墙壁，不可通过。<br>比如说，给定一个二维数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] maze = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>它表示这个迷宫，灰色为墙壁，白色为通路：<br><img src="/DFS/Maze.jpg" title="迷宫"><br>现在，给定一个起点和终点，找出一条可行的路径来走出这个迷宫。</p><p>不妨以上图为例子，起点为(1, 1)，终点为(6, 5)。</p><p>如何用DFS的实现来解决迷宫问题？我们走到一个点时（必然的，这个点的值为0，即为通路），我们可以选择向上、向下、向左或者是向右走；而前面的问题，都是一个父节点带着n个子节点的情形，我们可以照葫芦画瓢，父节点就是当前节点，而子节点就是上、下、左以及右的节点，画成图的话是这样的：<br><img src="/DFS/FourStep.jpg" title="子结构"></p><p>先对这个子结构进行遍历，伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Traversal currentPoint and its North, South, West and East Point</span><br><span class="line">// Input: maze, currentPoint</span><br><span class="line"></span><br><span class="line">function traversalCurrentPoint(Maze maze, Point currentPoint):</span><br><span class="line">    for point in &#123;currentPoint.North, currentPoint.South, currentPoint.West, currentPoint.East&#125; :</span><br><span class="line">        traversalCurrentPoint(point)</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>接下来确定好边界条件，初始条件当然是给一个起点，停止向下递归的条件是：</p><ol><li>遇上墙壁</li><li>遇上终点</li></ol><p>所以，对每个子结构遍历的伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Solve Maze Problem</span><br><span class="line">// Input: maze, start, end</span><br><span class="line"></span><br><span class="line">function solveMaze(Maze maze, Point start, Point end, Result result):</span><br><span class="line">    if start == end then </span><br><span class="line">        result.add(start)</span><br><span class="line">        return</span><br><span class="line">    else if is not wall then </span><br><span class="line">        result.add(start)</span><br><span class="line">        for Point in &#123;start.North, start.South, start.West, start.East&#125; :</span><br><span class="line">            solveMaze(maze, start, end, result)</span><br><span class="line">        result.remove(start)</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>因此，相应的Java代码实现有：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Point[] getPoints(Point currentPoint) &#123;</span><br><span class="line">    <span class="keyword">int</span> currentX = currentPoint.x;</span><br><span class="line">    <span class="keyword">int</span> currentY = currentPoint.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Point[]&#123;</span><br><span class="line">            <span class="keyword">new</span> Point(currentX - <span class="number">1</span>, currentY), <span class="comment">// North</span></span><br><span class="line">            <span class="keyword">new</span> Point(currentX + <span class="number">1</span>, currentY), <span class="comment">// South</span></span><br><span class="line">            <span class="keyword">new</span> Point(currentX, currentY - <span class="number">1</span>), <span class="comment">// West</span></span><br><span class="line">            <span class="keyword">new</span> Point(currentX, currentY + <span class="number">1</span>)  <span class="comment">// East</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">solveMaze</span><span class="params">(<span class="keyword">int</span>[][] maze, List&lt;Point&gt; result, Point start, Point end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = start.x;</span><br><span class="line">    <span class="keyword">int</span> y = start.y;</span><br><span class="line">    <span class="keyword">if</span> (x == end.x &amp;&amp; y == end.y) &#123;</span><br><span class="line">        result.add(start);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.add(start);</span><br><span class="line">        Point[] points = getPoints(start);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isValidPoint(maze, points[i])</span><br><span class="line">                   &amp;&amp; hasNotAccess(result, points[i])</span><br><span class="line">                   &amp;&amp; solveMaze(maze, result, points[i], end)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.remove(start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中isValidPoint()会判断是否越界或者遇上墙壁；而hasNotAccess()会判断节点是否被访问过，这么做可以防止<code>North -&gt; South -&gt; North ...</code>或者<code>East -&gt; West -&gt; East ...</code>的死循环。</p><p>代码的思路就是把所有子节点转换成可以被for循环枚举，每走一步，以当前节点为父节点继续枚举（即向下遍历），直到遇到终点或者墙壁后回溯。其实，这段DFS代码的可以转换成一个n重循环。</p><h3 id="4-2-不重复的字符的字符串"><a href="#4-2-不重复的字符的字符串" class="headerlink" title="4.2. 不重复的字符的字符串"></a>4.2. 不重复的字符的字符串</h3><p>其实这题不是LeetCode上的，是我从同学那里听说的。听完题目之后觉得挺有意思的，觉得用DFS可解，然后码了下代码，发现真的可以。<br>这道题是这么描述的：</p><p>给定一个没有重复字符的字符串s，字符串的第i个字符用s<sub>i</sub>表示，即s = s<sub>1</sub>s<sub>2</sub>s<sub>3</sub>…s<sub>i</sub>…s<sub>n</sub><br>请给出k个不重复的，由s[1…n]组成的，没有重复字符，长度为n的字符串。<br>Example 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;Input:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = “01234567”, k = 3<br>&nbsp;&nbsp;&nbsp;&nbsp;Output:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”01234567”, “74625310”, “45367201”</p><p>Example 2:<br>&nbsp;&nbsp;&nbsp;&nbsp;Input:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s =”abc”, k = 5<br>&nbsp;&nbsp;&nbsp;&nbsp;Output:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”abc”, “bca”, “cba”, “acb”, “bac”</p><p>给定的字符串s是一维的，明显不能直接用DFS来搜索。能使用DFS，数据必须是二维的。于是我们可以构造一个矩阵，矩阵就是二维的，以s = “abcd”为例，如下：<br><img src="/DFS/Matrix.jpg" title="构造矩阵"></p><p>为什么我会想到构造一个矩阵出来？原因不难理解。前面我不断的说：<code>DFS代码可以转换成一个n重循环</code>。n重循环很好枚举，所以我就构造出一个4*4的矩阵，每一行都是s<br>这样我就能写成如下形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for i in 0 ~ 3:</span><br><span class="line">    for j in 0 ~ 3: </span><br><span class="line">        for m in 0 ~ 3: </span><br><span class="line">            for n in 0 ~ 3: </span><br><span class="line">                rs = s[i] + s[j] + s[m] + s[n]</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>然后我就可以转成递归的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in 0 ~ 3: </span><br><span class="line">    DFS(s, i)</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>转换成递归形式，可能就就不大容易看懂了，我们来看看这张图：<br><img src="/DFS/no_repeating_str_i_next_status.jpg" title="状态转移"><br>当我们走到了第<code>i</code>个字符串时，接下来该往<code>s1...sn</code>走，于是我们可以用循环来枚举。</p><p>所以，相应的实现代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bruteSearch</span><span class="params">(String[] targetCharMatrix, StringBuilder stringBuilder, List&lt;String&gt; result, <span class="keyword">int</span>[] accessFlag, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth &lt; targetCharMatrix.length) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; targetCharMatrix[depth].length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (accessFlag[i] != <span class="number">1</span>) &#123;</span><br><span class="line">                stringBuilder.append(targetCharMatrix[depth].charAt(i));</span><br><span class="line">                accessFlag[i] = <span class="number">1</span>;</span><br><span class="line">                bruteSearch(targetCharMatrix, stringBuilder, result, accessFlag, depth + <span class="number">1</span>);</span><br><span class="line">                accessFlag[i] = <span class="number">0</span>;</span><br><span class="line">                stringBuilder.deleteCharAt(stringBuilder.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.add(stringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先解释一下参数列表：<br>其中targetCharMatrix是根据s构造出来的矩阵；<br>stringBuilder是用来拼接字符的对象；<br>result是用来存放结果的对象；<br>accessFlag是存放访问结果，如果第i个元素为0则表示第i个字符还没被访问（拼接），否则如果为1则表明已经被访问（拼接）过；<br>depth表示已经拼接字符的个数。</p><p>然后就是方法体：<br>首先判断是否超过最大深度，即<code>depth</code>是否等于4。<br>如果小于4：那就遍历<code>targetCharMatrix[depth][0...3]</code>。如果<code>targetCharMatrix[depth][i]</code>没被访问过，那就把<code>accessFlag[i]</code>置1，然后用<code>stringBuilder</code>把<code>targetCharMatrix[depth][i]</code>拼接进来，然后向下遍历，直至回溯回来后，将访问标志<code>accessFlag[i]</code>置0，把<code>targetCharMatrix[depth][i]</code>从<code>stringBuilder</code>中移除。</p><p>否则，如果<code>depth</code>等于4：说明此时<code>stringBuilder.length() == 4</code>，那就把它加到结果<code>result</code>里就ok了。其实还是一个n重循环问题。</p><p>其实，直接传一个矩阵(String[] targetCharMatrix)没有必要，因为这个矩阵的每行都一样。我们只需要传一个原字符串(即矩阵的任意一行)，再用depth来控制最大深度(矩阵的行数)就可以了。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bruteSearch</span><span class="params">(String targetChar, StringBuilder stringBuilder, List&lt;String&gt; result, <span class="keyword">int</span>[] accessFlag, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; targetChar.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (accessFlag[i] != <span class="number">1</span>) &#123;</span><br><span class="line">                stringBuilder.append(targetChar.charAt(i));</span><br><span class="line">                accessFlag[i] = <span class="number">1</span>;</span><br><span class="line">                bruteSearch(targetChar, stringBuilder, result, accessFlag, depth - <span class="number">1</span>);</span><br><span class="line">                accessFlag[i] = <span class="number">0</span>;</span><br><span class="line">                stringBuilder.deleteCharAt(stringBuilder.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.add(stringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-由两个问题所引发的思考"><a href="#5-由两个问题所引发的思考" class="headerlink" title="5. 由两个问题所引发的思考"></a>5. 由两个问题所引发的思考</h2><p>上面已经解释了，DFS可以写成n重循环的形式。所以DFS和n重循环有什么关系？<br>DFS的基本形式，就是一个循环内调用自身。即一个循环+递归的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function DFS(graph, depth):</span><br><span class="line">    if depth &lt; maxDepth then</span><br><span class="line">        for i in 0 ~ graph.get(depth).length():</span><br><span class="line">            access(graph, depth)</span><br><span class="line">            DFS(graph, depth + 1)</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>如果<code>graph</code>是4*4的，如果调用<code>DFS(graph, 0)</code>，<br>那么第一层：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in 0 ~ 3:</span><br><span class="line">    if 0 &lt; 4 then</span><br><span class="line">        access(graph, 0)</span><br><span class="line">        DFS(graph, 0 + 1)</span><br><span class="line">        end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>第二层：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in 0 ~ 3:</span><br><span class="line">    if 1 &lt; 4 then</span><br><span class="line">        access(graph, 1)</span><br><span class="line">        DFS(graph, 1 + 1)</span><br><span class="line">        end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>第三层：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in 0 ~ 3:</span><br><span class="line">    if 2 &lt; 4 then</span><br><span class="line">        access(graph, 2)</span><br><span class="line">        DFS(graph, 2 + 1)</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>第四层：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in 0 ~ 3:</span><br><span class="line">    if 3 &lt; 4 then</span><br><span class="line">        access(graph, 3)</span><br><span class="line">        DFS(graph, 3 + 1)</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>把第i层的<code>DFS(graph, (i - 1) + 1)</code>替换成第i + 1层的代码，可以得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">for i in 0 ~ 3:</span><br><span class="line">    if 0 &lt; 4 then</span><br><span class="line">        access(graph, 0)</span><br><span class="line">        for i in 0 ~ 3:</span><br><span class="line">            if 1 &lt; 4 then</span><br><span class="line">                access(graph, 1)</span><br><span class="line">                for i in 0 ~ 3:</span><br><span class="line">                    if 2 &lt; 4 then</span><br><span class="line">                        access(graph, 2)</span><br><span class="line">                        for i in 0 ~ 3:</span><br><span class="line">                            if 3 &lt; 4 then</span><br><span class="line">                                access(graph, 3)</span><br><span class="line">                                DFS(graph, 3 + 1)</span><br><span class="line">                            end</span><br><span class="line">                        end</span><br><span class="line">                    end</span><br><span class="line">                end</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>从上面可以看出，DFS本质就是一个n重循环，DFS自然可以用n重循环来表示。</p><p>其实，观察每一层，每一层不一样的地方也就只有传的参数的值不同，也能看出这就是一个n重循环，有点像数学归纳法的递推。<br>还有就是，我上面不断的提<code>子结构</code>，其实我个人觉得能写成递归解决的问题，都很像数学中的分形。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><ol><li>如果一个枚举问题，它的子结构共同组成该问题，就像上面提到的迷宫问题一样，每走一步后，可以上下左右走，这是一个子结构，共同组成原问题，那么这个问题就可以写成n重循环的形式。既然能够写成n重循环的形式，自然就能转化成递归的形式，就能用DFS的思想解决。</li><li>如果一个枚举问题，它的子结构不能组成该问题，那我们就可以转化一下，如果能转化成让它可以由子结构组成，就像上面提到的不重复字符的字符串一样，一维的字符串自然没有子结构能够组成这个问题，那我们就构造一个矩阵，这样我们就能在递归深度为depth时，访问第1，第2 … 第n个元素，写成n重循环的形式，从而转化成递归进而用DFS的实现解决。</li><li>DFS是解决枚举问题的基础，但不是所有问题都能照搬DFS的代码得到解决，需要具体情况具体分析。</li></ol><h2 id="7-感想"><a href="#7-感想" class="headerlink" title="7. 感想"></a>7. 感想</h2><p>在这之前，我对DFS的理解，也仅仅只是对二叉树的遍历。刷了一定量的题，我慢慢发现，只要给初始条件和停止条件，递归可以解决需要多重循环的问题，也就是DFS的实现。所以刷题还是有用的！想要对算法有理解还是要多刷题(不会可以看看Discussion，里面各路大神各种骚操作，都能解决问题)。就这样吧。如果本文有什么问题，请指教，共同进步，谢谢~！</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/DFS/cover.jpeg&quot;&gt;
&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;上周刷了20来道LeetCode的题，总结出了一些关于深度优先搜索的小小的心得，于是有了这篇博客。这次的总体思路是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;深度优先搜索算法的工作过程&lt;/li&gt;
&lt;li&gt;如何使用深度优先搜索算法来进行遍历&lt;/li&gt;
&lt;li&gt;两个有趣的问题&lt;/li&gt;
&lt;li&gt;深度优先搜索算法和循环的关系&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="www.zspirytus.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>可拖拽的FloatingActionButton</title>
    <link href="www.zspirytus.com/DraggableFloatingActionButton/"/>
    <id>www.zspirytus.com/DraggableFloatingActionButton/</id>
    <published>2018-08-22T10:52:48.000Z</published>
    <updated>2018-10-02T18:17:39.428Z</updated>
    
    <content type="html"><![CDATA[<img src="/DraggableFloatingActionButton/draggablefloatingactionbutton_cover.jpg" title="cover"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>FloatingActionButton是Google力推的一个Material Design控件。最近做的一个项目，需要实现一个可以左右滑动，松手回到原位的FloatingActionButton。研究了大半天就写出来了，于是写写这片博客记录一下。</p><a id="more"></a><h2 id="MotionEvent的事件"><a href="#MotionEvent的事件" class="headerlink" title="MotionEvent的事件"></a>MotionEvent的事件</h2><p>当我们点击一个view，或者拖动一个view到处滑动时，都会产生一个MotionEvent事件。</p><ul><li>当我们的手指刚刚点击到屏幕时，会产生MotionEvent.ACTION_DOWN事件；</li><li>当我们的手指在屏幕上到处滑动时，会产生MotionEvent.ACTION_MOVE事件；</li><li>当我们的手指离开屏幕时，会产生MotionEvent.ACTION_UP事件。</li></ul><p>那么这就好办了，当产生了MotionEvent.ACTION_MOVE事件时，只需要获得屏幕触点的坐标，把fab移动过去就行了</p><h2 id="设置OnTouchListener"><a href="#设置OnTouchListener" class="headerlink" title="设置OnTouchListener"></a>设置OnTouchListener</h2><p>前面已经说明了，view会产生MotionEvent.ACTION_DOWN，MotionEvent.ACTION_MOVE 和 MotionEvent.ACTION_UP事件。问题是如何捕获这些事件。当我们的手指开始接触屏幕，直到离开屏幕前，View.onTouch()方法都会被调用，而且这个方法的参数中有MotionEvent参数，可以获取事件。因此我们需要实现该方法，并为fab设置OnTouchListener监听器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mFab.setOnTouchListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View view, MotionEvent motionEvent)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就可以通过motionEvent来获得事件，并根据事件来响应。实现的思路已经很明显了，接下来分事件来说明。</p><h3 id="MotionEvent-ACTION-DOWN"><a href="#MotionEvent-ACTION-DOWN" class="headerlink" title="MotionEvent.ACTION_DOWN"></a>MotionEvent.ACTION_DOWN</h3><p>当手指开始接触屏幕时，会产生MotionEvent.ACTION_DOWN事件。<br>这时要做一件事，记录下『mFab初始坐标X值和触点坐标X值之差』，以供备用。<br>其中initRawX为mFab的初始坐标的X值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">    dX = initRawX - motionEvent.getRawX();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><h3 id="MotionEvent-ACTION-MOVE"><a href="#MotionEvent-ACTION-MOVE" class="headerlink" title="MotionEvent.ACTION_MOVE"></a>MotionEvent.ACTION_MOVE</h3><p>当手指开始在屏幕上滑动时，会产生MotionEvent.ACTION_MOVE事件。<br>这时需要实现mFab跟随手指移动的功能。<br>要实现mFab移动的功能，我们必须计算出手指移动的距离deltaX，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deltaX = (motionEvent.getRawX() - initRawX + dX) * damping;</span><br></pre></td></tr></table></figure><p>其中damping是阻尼，0 &lt; damping &lt;= 1.</p><p>计算出手指移动的距离deltaX后：</p><ul><li>当移动的距离deltaX满足 -CLICK_DRAG_TOLERANCE &lt; deltaX &lt; CLICK_DRAG_TOLERANCE时，mFab不用移动，因为我们单击mFab时，是不需要mFab移动的。</li><li>当移动的距离deltaX满足 deltaX &gt; border 或 deltaX &lt; -border 时，mFab则停留在border或-border的位置就可以了。</li></ul><p>所以便有：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (deltaX &lt; -border) &#123;</span><br><span class="line">    deltaX = -border;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaX &lt; -CLICK_DRAG_TOLERANCE) &#123;</span><br><span class="line">    setImageResource(R.drawable.ic_skip_previous_white_48dp);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaX &gt; CLICK_DRAG_TOLERANCE &amp;&amp; deltaX &lt;= border) &#123;</span><br><span class="line">    setImageResource(R.drawable.ic_skip_next_white_48dp);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaX &gt; border) &#123;</span><br><span class="line">    deltaX = border;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Math.abs(deltaX) &gt;= CLICK_DRAG_TOLERANCE) &#123;</span><br><span class="line">    <span class="comment">// 此时deltaX已经大于mFab移动的阈值CLICK_DRAG_TOLERANCE，mFab移动deltaX个单位。</span></span><br><span class="line">    view.animate()</span><br><span class="line">        .x(initRawX + deltaX)</span><br><span class="line">        .setDuration(RESPONSE_ACTION_MOVE_DELAY)</span><br><span class="line">        <span class="comment">// RESPONSE_ACTION_MOVE_DELAY == 0，立即移动</span></span><br><span class="line">        .start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><br>其中CLICK_DRAG_TOLERANCE是mFab能移动距离的阈值。</p><h3 id="MotionEvent-ACTION-UP"><a href="#MotionEvent-ACTION-UP" class="headerlink" title="MotionEvent.ACTION_UP"></a>MotionEvent.ACTION_UP</h3><p>当手指离开屏幕时，会产生MotionEvent.ACTION_UP事件。<br>这个时候就可以处理单击、左滑和右滑的事件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (onDraggableFABEventListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(deltaX) &lt; CLICK_DRAG_TOLERANCE) &#123;</span><br><span class="line">        onDraggableFABEventListener.onClick();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (deltaX == border) &#123;</span><br><span class="line">            onDraggableFABEventListener.onDraggedRight();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaX == -border) &#123;</span><br><span class="line">            onDraggableFABEventListener.onDraggedLeft();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果deltaX的绝对值小于CLICK_DRAG_TOLERANCE，则表明是单击事件；<br>否则如果deltaX == border，则表明是右滑事件；<br>否则如果deltaX == -border，则表明是左滑事件。</p><p>处理完事件后，mFab要回到原位，因此：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">view.animate()</span><br><span class="line">        .x(initRawX)</span><br><span class="line">        .setDuration(RESET_ANIMATOR_DURATION)</span><br><span class="line">        <span class="comment">// RESET_ANIMATOR_DURATION &gt; 0</span></span><br><span class="line">        .start();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></p><p>至此，整个onTouch方法就完成了！以下是完整代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View view, MotionEvent motionEvent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> action = motionEvent.getAction();</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            dX = initRawX - motionEvent.getRawX();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            deltaX = (motionEvent.getRawX() - initRawX + dX) * damping;</span><br><span class="line">            <span class="keyword">if</span> (deltaX &lt; -border) &#123;</span><br><span class="line">                deltaX = -border;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaX &lt; -CLICK_DRAG_TOLERANCE) &#123;</span><br><span class="line">                setImageResource(R.drawable.ic_skip_previous_white_48dp);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaX &gt; CLICK_DRAG_TOLERANCE &amp;&amp; deltaX &lt;= border) &#123;</span><br><span class="line">                setImageResource(R.drawable.ic_skip_next_white_48dp);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaX &gt; border) &#123;</span><br><span class="line">                deltaX = border;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(deltaX) &gt;= CLICK_DRAG_TOLERANCE) &#123;</span><br><span class="line">                view.animate()</span><br><span class="line">                        .x(initRawX + deltaX)</span><br><span class="line">                        .setDuration(RESPONSE_ACTION_MOVE_DELAY)</span><br><span class="line">                        .start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="keyword">int</span> resId = MediaPlayController.getInstance().isPlaying() ? R.drawable.ic_pause_white_48dp : R.drawable.ic_play_arrow_white_48dp;</span><br><span class="line">            setImageResource(resId);</span><br><span class="line">            <span class="keyword">if</span> (onDraggableFABEventListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(deltaX) &lt; CLICK_DRAG_TOLERANCE) &#123;</span><br><span class="line">                    onDraggableFABEventListener.onClick();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (deltaX == border) &#123;</span><br><span class="line">                        onDraggableFABEventListener.onDraggedRight();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaX == -border) &#123;</span><br><span class="line">                        onDraggableFABEventListener.onDraggedLeft();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            view.animate()</span><br><span class="line">                    .x(initRawX)</span><br><span class="line">                    .setDuration(RESET_ANIMATOR_DURATION)</span><br><span class="line">                    .start();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(motionEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="mFab的初始位置"><a href="#mFab的初始位置" class="headerlink" title="mFab的初始位置"></a>mFab的初始位置</h2><p>前面的onTouch方法需要initRawX的值，我们如何获得这个值？<br><code>this.getX()</code>是不可行的，因为当执行<code>this.getX()</code>的时候，不能保证mFab已经被绘制出来了；而如果mFab没有绘制出来，<code>this.getX()</code>将会返回0。因此我们需要在适当的实际调用<code>this.getX()</code>来获取initRawX。<br>onWindowFocusChanged()方法是在Activity的onResume()后被调用，当Activity的onResume()方法被调用后，Activity是可见，可与用户交互的，说明view都已经绘制完毕，所以我们可以在onWindowFocusChanged()方法中获取mFab的初始坐标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasWindowFocus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onWindowFocusChanged(hasWindowFocus);</span><br><span class="line">    <span class="comment">// get mFab initial location X</span></span><br><span class="line">    initRawX = getX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实可拖拽的FloatingActionButton的实现原理很简单，只需要为mFab设置OnTouchListener，在监听器中捕获MotionEvent.ACTION_DOWN、MotionEvent.ACTION_MOVE、MotionEvent.ACTION_UP 事件，再分别处理事件即可。完整代码可以看<a href="https://github.com/zkw012300/DraggableFloatingActionButton/blob/master/mylibrary/src/main/java/com/zspirytus/mylibrary/DraggableFloatingActionButton.java" target="_blank" rel="noopener">这里</a>。</p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>之前看Android中的View事件的分发机制，第一次接触到了ACTION_DOWN、ACTION_MOVE、ACTION_UP事件，看了一遍云里雾里的，但是多看几遍后就开始理解。这次的可拖拽的FloatingActionButton是我在写的项目中的一个小控件，有了之前的基础，写起来不太吃力。所以我认为这三个事件还是蛮重要的。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/DraggableFloatingActionButton/draggablefloatingactionbutton_cover.jpg&quot; title=&quot;cover&quot;&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;FloatingActionButton是Google力推的一个Material Design控件。最近做的一个项目，需要实现一个可以左右滑动，松手回到原位的FloatingActionButton。研究了大半天就写出来了，于是写写这片博客记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="www.zspirytus.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>设计模式——观察者模式</title>
    <link href="www.zspirytus.com/Observer/"/>
    <id>www.zspirytus.com/Observer/</id>
    <published>2018-07-26T15:54:55.000Z</published>
    <updated>2018-10-02T18:20:32.323Z</updated>
    
    <content type="html"><![CDATA[<img src="/Observer/observer_cover.jpeg" title="cover"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>嗯，观察者模式在Android开发中还是挺常用的，比如说Adapter数据更新后RecyclerView的刷新，以及四大组件的Broadcast等等。接下来本文将简单谈谈设计模式中的观察和模式。<br>为了有更好的食用体验，本文会结合一个简单的例子，让你更好的理解观察者模式。<br><a id="more"></a></p><h2 id="一、观察者模式"><a href="#一、观察者模式" class="headerlink" title="一、观察者模式"></a>一、观察者模式</h2><p>先来看看定义：定义对象之间的一对多依赖关系，当一个对象改变状态时，它的所有依赖对象都会自动获得通知。<br>emmm…一对多依赖关系？？？状态改变依赖对象会被通知？？？定义有点拗口，不如直接看看一个例子。<br>小时候各位都有做过眼保健操吧，当广播响起眼保健操的音乐时，我们就开始做眼保健操。此时，广播和学生构成了一对多的依赖：当广播播放眼保健操的音乐时，即广播的状态发生改变时，我们获得要开始做眼保健操的通知。</p><h2 id="二、观察者模式中的角色"><a href="#二、观察者模式中的角色" class="headerlink" title="二、观察者模式中的角色"></a>二、观察者模式中的角色</h2><p>观察者模式，就像它的名字一样，这个设计模式中有一个角色叫『观察者』，同样的也有一个角色叫『被观察者』。它们都是抽象出来的概念，因此它们的具体的实现是『具体观察者』和『具体被观察者』。<br>在上面的例子中，『广播』扮演的的是『被观察者』的角色；『发送眼保健操音乐的广播』扮演的是『具体被观察者』的角色；『学生』扮演的是『具体观察者』的角色；而『观察者』的角色并不明显，它扮演的是接口的角色。如下例子：<br>定义观察者：<br><figure class="highlight java"><figcaption><span>Observer.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(BroadCast broadCast)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义具体观察者——Student<br><figure class="highlight java"><figcaption><span>Student.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = Student.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(BroadCast broadCast)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"send Eye Exercises BroadCast! "</span>.equals(broadCast.getBroadCast())) &#123;</span><br><span class="line">            System.out.println(TAG + <span class="string">": I will do eye exercises!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(TAG + <span class="string">":I will be back home!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义被观察者——BroadCast：<br><figure class="highlight java"><figcaption><span>BroadCast.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadCast</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!observers.contains(observer)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (BroadCast.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!observers.contains(observer)) &#123;</span><br><span class="line">                    observers.add(observer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unRegister</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!observers.contains(observer)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (BroadCast.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!observers.contains(observer)) &#123;</span><br><span class="line">                    observers.remove(observer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notifyAllObserver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Iterator&lt;Observer&gt; iterator = observers.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Observer observer = iterator.next();</span><br><span class="line">            observer.doSomething(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getBroadCast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sendBroadCast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义具体的被观察者——眼保健操广播和放学铃声广播：<br><figure class="highlight java"><figcaption><span>EyeExercisesBroadCast.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EyeExercisesBroadCast</span> <span class="keyword">extends</span> <span class="title">BroadCast</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EyeExercisesBroadCast INSTANCE = <span class="keyword">new</span> EyeExercisesBroadCast();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String broadCastMessage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EyeExercisesBroadCast</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EyeExercisesBroadCast <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBroadCast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> broadCastMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadCast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        broadCastMessage = <span class="string">"send Eye Exercises BroadCast! "</span>;</span><br><span class="line">        notifyAllObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><figcaption><span>FinishClassBroadCast.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinishClassBroadCast</span> <span class="keyword">extends</span> <span class="title">BroadCast</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FinishClassBroadCast INSTANCE = <span class="keyword">new</span> FinishClassBroadCast();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String broadCastMessage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FinishClassBroadCast</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FinishClassBroadCast <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBroadCast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> broadCastMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadCast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        broadCastMessage = <span class="string">"send finish class BroadCast! "</span>;</span><br><span class="line">        notifyAllObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外在定义两个辅助类Main和Teacher，Main负责执行代码，而Teacher是广播的管理者，可以管理广播的发送<br><figure class="highlight java"><figcaption><span>Main.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        BroadCast broadCast1 = EyeExercisesBroadCast.getInstance();</span><br><span class="line">        BroadCast broadCast2 = FinishClassBroadCast.getInstance();</span><br><span class="line">        broadCast1.register(student);</span><br><span class="line">        broadCast2.register(student);</span><br><span class="line">        Teacher teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><figcaption><span>Teacher.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = Teacher.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BroadCast[] broadCasts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        System.out.println(TAG+<span class="string">": I send eye exercises broadcast! "</span>);</span><br><span class="line">        sendEyeExercisesBroadCast();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep((<span class="keyword">int</span>) (Math.random() * <span class="number">6</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(TAG+<span class="string">": I send finish class broadcast! "</span>);</span><br><span class="line">        sendFinishClassBroadCast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        broadCasts = <span class="keyword">new</span> BroadCast[<span class="number">2</span>];</span><br><span class="line">        broadCasts[<span class="number">0</span>] = EyeExercisesBroadCast.getInstance();</span><br><span class="line">        broadCasts[<span class="number">1</span>] = FinishClassBroadCast.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendEyeExercisesBroadCast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        broadCasts[<span class="number">0</span>].sendBroadCast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendFinishClassBroadCast</span><span class="params">()</span></span>&#123;</span><br><span class="line">        broadCasts[<span class="number">1</span>].sendBroadCast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时运行程序，当广播播放眼保健操的音乐时，学生便收到通知，开始做眼保健操；当广播播放放学铃声时，学生便收到通知，开始离校。运行结果如下：<br><img src="/Observer/result.png" title="运行结果"></p><h2 id="三、观察者模式的工作原理"><a href="#三、观察者模式的工作原理" class="headerlink" title="三、观察者模式的工作原理"></a>三、观察者模式的工作原理</h2><p>在观察者模式中，Observer观察Observable。这个过程有几个关键点：</p><ul><li>与大部分现实不同的是，Observer不是主动观察，而是被动的接收来自Observable的通知</li><li>Observable要知道谁在观察它，才能在状态改变的时候通知，因此它需要维护一个List&lt;Observer></li><li>Observer中要有一个传入Observable参数的回调方法，以便Observer在收到通知时能够获得Observable的状态</li></ul><p>首先，Observer是被动的接收来自Observable的通知，因为我们引入观察者模式的目的之一就是为了避免轮询消耗CPU资源，所以比较合适的方法应该是当Observable状态发生改变时再去通知Observer。就像上面的例子，脑补一下画面：学生不必不停的问老师：放学了吗？放学了吗？放学了吗？…老师回答：没有。没有。没有。…放学了。这样很喜感，也太消耗体力(CPU资源)。</p><p>其次，正是因为Observable需要通知Observer，所以Observable需要知道谁是Observer，即需要存储所有Observer对象，因此它需要维护一个List&lt;Observer>，至于List&lt;Observer>的数据结构如何选用，就要看看实际情况了。就像上面的例子：因为广播(即Observable)知道它要通知的是学生，所以才会被安装在教室和走廊里(不然装在闹市区突然响起眼保健操的音乐，路人一脸黑人问号)。</p><p>最后，Observer需要知道Observable的通知内容，因此Observable要在回调函数(的参数)中放入通知内容，Observer可以在回调函数中(的参数)获得通知内容。在上面的例子中，学生是可以通过广播获得放学的信息的。</p><p>另外，如果存在优先级的问题，可以List&lt;Observer>把按优先级排序以下，再进行通知。如果在通知的时候(for循环里面)加一点逻辑，可以实现类似于Android系统中有序广播的功能。</p><h2 id="四、回调函数的参数列表"><a href="#四、回调函数的参数列表" class="headerlink" title="四、回调函数的参数列表"></a>四、回调函数的参数列表</h2><p>在第三部分提到，Observer可以通过回调函数获取通知内容。但是这个通知内容是什么？是直接传一个Observable参数好，还是直接传message参数的参数好？还是两个一起传？不如分别讨论。</p><h3 id="4-1-只传Observable参数"><a href="#4-1-只传Observable参数" class="headerlink" title="4.1.只传Observable参数"></a>4.1.只传Observable参数</h3><p>只传Observable参数，简单，不会有一大堆重载函数。但是可能会有意想不到的安全问题：Student类实现了Observer接口，可以通过doSomething(BroadCast)获取BroadCast对象，然而BroadCast的notifyAllObserver方法是public的！即使我们相信学生不会为了恶作剧而重复发广播，但是这个问题还是有可能发生的。从编程的角度，在代码运行时，如果观察者接收到信息后调用BroadCast.notifyAllObserver()方法后，是会爆栈的。比如说，修改Student.doSomething(BroadCast)方法：<br><figure class="highlight java"><figcaption><span>Student.doSomething(BroadCast)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(BroadCast broadCast)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"send Eye Exercises BroadCast! "</span>.equals(broadCast.getBroadCast()))&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName()+<span class="string">": I will do eye exercises!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName()+<span class="string">":I will be back home!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    broadCast.notifyAllObserver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里增加了一行broadCast.notifyAllObserver()，再重新执行main方法，结果如下：</p><img src="/Observer/StackBomb.png" title="StackBomb"><p>很不幸爆栈了。因此我们要把notifyAllObserver方法屏蔽掉，只有BroadCast及其它的子类能碰。因此notifyAllObserver方法需要被protected关键词修饰，并且其BroadCast的子类需要和BroadCast同包。修改后包结构如下：</p><img src="/Observer/PackageStructure.png" title="Package Structure"><p>通过修改notifyAllObserver()的访问权限，就能解决安全问题。</p><h3 id="4-2-只传message参数"><a href="#4-2-只传message参数" class="headerlink" title="4.2.只传message参数"></a>4.2.只传message参数</h3><p>只传message参数？似乎看起来并没有什么问题。但是message可能不止一个！而且Observable不知道Observer需要什么样的message。假设多个Observer要观察Observable中的n个message中任意多个，它们需要的message可能各不相同。所以回调函数就必须要有2<sup>n</sup>个，这样才可以满足所有Observer的需求。显然这样是不可取的，因为重载函数的增加降低了程序的可维护性。同时，当Observer观察多个Observable时，当某一个Observable通知它时，Observer无法得知是哪个Observable更新了，所以只传message参数是有一定局限的。</p><h3 id="4-3-同时传Observable和message"><a href="#4-3-同时传Observable和message" class="headerlink" title="4.3.同时传Observable和message"></a>4.3.同时传Observable和message</h3><p>4.2中已经说明，当message有多个时，需要对应指数级个的回调函数，所以在这种多个message的情况下，还是尽量不要传message参数为好。</p><p>所以，个人认为回调函数因只需要传入一个Observable参数。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>一个类可以实现Observer接口来获得『观察』的功能；一个类可以实现Observable接口/抽象类来获得『可观察』的属性。当观察者需要观察被观察者时，它需要实例化出一个被观察者对象，然后调用被观察者的注册方法来注册自己，以便被观察者状态改变时，能够通知自己。<br>个人认为，观察者模式本质是维护一个回调函数集合，在被观察者发生改变时，被观察者便逐个调用这些回调函数，这时观察者就被通知了。<br>另外，基于观察者模式的特性，个人认为观察者模式特别适用于一些异步操作，比如IO操作和网络请求(下载图片并显示在ImageView上等)。</p><h2 id="六、感想"><a href="#六、感想" class="headerlink" title="六、感想"></a>六、感想</h2><p>事实上观察者模式不是我第一个接触的设计模式，我第一个接触的设计模式是『构建者模式』，当时是在学Android开发中的自定义View，没有资料来源所以只能硬啃别人的自定义View的代码，在里面View有必选属性和可选属性，多个构造方法重载和JavaBean模式都不理想，因此构建者模式才被设计出来，结合了这个场景，我也就理解了构建者模式的设计初衷和原理。回到观察者模式，在学Android开发的时候，使用到了RecyclerView，当时不理解为什么它的数据更新的机制，后来看了这本书<a href="https://book.douban.com/subject/26744163/" target="_blank" rel="noopener">《Android开发进阶从小工到专家》</a>，原来RecyclerView的数据更新是适配器模式+观察者模式！结合这本书里面的部分源码，我才理解了RecyclerView的数据更新机制，也就顺手理解了观察者模式的设计初衷。<br>所以设计模式，还是要结合实际场景来学，才能更容易理解然后运用。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/Observer/observer_cover.jpeg&quot; title=&quot;cover&quot;&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;嗯，观察者模式在Android开发中还是挺常用的，比如说Adapter数据更新后RecyclerView的刷新，以及四大组件的Broadcast等等。接下来本文将简单谈谈设计模式中的观察和模式。&lt;br&gt;为了有更好的食用体验，本文会结合一个简单的例子，让你更好的理解观察者模式。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="www.zspirytus.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>快速排序不快了？重复元素下的快速排序</title>
    <link href="www.zspirytus.com/quicksort/"/>
    <id>www.zspirytus.com/quicksort/</id>
    <published>2018-07-24T10:21:14.000Z</published>
    <updated>2018-10-02T18:23:40.174Z</updated>
    
    <content type="html"><![CDATA[<img src="/quicksort/quicksort_cover.jpeg" title="cover"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>快速排序，就像它的名字一样，它做排序很快，空间复杂度O(1)下，它的平均时间复杂度为O(nlog<sub>2</sub>n)。但是在某些情况下，快速排序不快了，表现出来的性能和冒泡排序排序这类时间复杂度为O(n<sup>2</sup>)相差无几。因此，本文将解决：</p><ul><li>快速排序的工作原理</li><li>重复元素下的快排</li><li>基本有序下数组下的快排</li></ul><a id="more"></a><h2 id="一、快速排序是如何工作的？"><a href="#一、快速排序是如何工作的？" class="headerlink" title="一、快速排序是如何工作的？"></a>一、快速排序是如何工作的？</h2><p>个人理解，快速排序的工作原理：每轮任意选定一个支点pivot然后确认其最终的位置，然后对支点两边的进行相同的操作，逐渐靠近直至到达有序状态的过程。因此快速排序是分区+递归，分而治之的。</p><h3 id="1-1-分区"><a href="#1-1-分区" class="headerlink" title="1.1.分区"></a>1.1.分区</h3><p>可以看出，快速排序的核心在于：分区。即确定选定支点pivot的最终位置。支点的最终位置在哪里？如果支点的最终位置为x，对于数组arr必然满足</p><p><div style="text-align: center;">arr[0…x-1] ≤ arr[x] ≤ arr[x+1…arr.length-1]</div><br>即：x的左边都比支点小或相等，x的右边都比支点大或相等。<br>所以我们可以使用两个指针i、j。在初始状态下i指向表头，j指向表尾。分区过程中，如果i指向的元素比支点值小，则i++；如果j指向的元素比支点大，则j--，直至i==j。此时i的值即为支点的最终位置。<br>但是，绝大部分待排数据都是无序的，在分区过程中，还存在这种情况：arr[i] &gt; pivotVaule, arr[j] &lt; pivotValue。这种情况会导致内循环不执行，但是外循环条件永真而陷入死循环。因此为了确保分区能顺利进行，遇上这种情况，只需交换i，j指向元素的值。交换完毕后，便回到 arr[i] ≤ pivotVaule, arr[j] ≥ pivotValue。<br>所以分区部分的代码就可以写了（pivot = low为例）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = low;</span><br><span class="line">    <span class="keyword">int</span> pivotValue = arr[pivot];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] ≥ pivotValue)</span><br><span class="line">            high--;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] ≤ pivotValue)</span><br><span class="line">            low++;</span><br><span class="line">        swap(arr,low,high);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr,pivot,low);</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这段代码有几个需要注意的地方：<br>1.pivot的值可以在[low…high]中任意取<br>2.在return前需要交换pivot和low所指向的值。<br>关于第二点，可以确定的是，pivot所指向的地址的对象，从始至终都不会发生改变，因为内循环的条件的第二个子条件都带了等号，说明i和j不会停留在pivot，而是会越过pivot，因此pivot所指向的地址的内容是不会被修改的。既然pivot指向的对象不变，且low为最终支点的位置，所以low和pivot指向的对象互相交换一下就OK了。</p><h3 id="1-2-递归"><a href="#1-2-递归" class="headerlink" title="1.2.递归"></a>1.2.递归</h3><p>递归对应分而治之中的治。为什么经过快速排序后，数组能够变成有序的？不如先看看代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = partition(arr, low, high);</span><br><span class="line">        quickSort(arr, low, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pivot + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>读完代码，可以得到以下信息：<br>1.条件判断是最优先的<br>2.递归过程类似于二叉树的先序遍历</p><p>对于第1点，条件判断先行是为了防止栈溢出或数组越界，没什么好讲的。<br>对于第2点，递归过程很像二叉树的先序遍历，如下图所示：<br><img src="/quicksort/quicksort_tree.png" title="普通快速排序递归树"><br>从图中可以看出，如果达到最大递归深度，即low+1=high，图中的叶子节点时会回溯，且每个叶子节点都是有序的，所以所有的叶子节点合起来从左至右是有序的。</p><h3 id="1-3-复杂度"><a href="#1-3-复杂度" class="headerlink" title="1.3.复杂度"></a>1.3.复杂度</h3><p>快排的时间性能如何？从上面可看出快排的过程类似一个二叉树的遍历，最大递归深度直接决定快排的时间性能。假设待排序数组是完全随机的，设时间频度为T(n)，在平均和最佳的情况下，有<br>T(n) = 2T(n/2) + n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;≤ 4T(n/4) + n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;≤ 8T(n/8) + n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;… …<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;≤ log<sub>2</sub>n + nlog<sub>2</sub>n</p><p>因为待排序数组是完全随机的，所以可以认为，i和j指针移动1，2，3…n次的概率为1/n，因此移动距离的期望为n/2，所以一份T(n)可以分成2个T(n/2)加上扫描一次的代价，且扫描一次的代价必然≤n的。所以平均和最佳的情况下，快排的时间复杂度均为O(nlog<sub>2</sub>n)。<br>同时，在最佳的情况下，T(n)同样也是被一分为二的，两份的大小相等，因此和平均的情况一样。</p><p>在最差的情况下，即数组完全有序，快排的时间性能直接退化到O(n<sup>2</sup>)，相当于冒泡排序，递归树退化成链表。</p><h2 id="二、重复元素下的快速排序"><a href="#二、重复元素下的快速排序" class="headerlink" title="二、重复元素下的快速排序"></a>二、重复元素下的快速排序</h2><p>重复元素较多下的快排递归树:<br><img src="/quicksort/quicksort_repeat.png" title="重复元素下的快速排序递归树"><br>从图中来看，似乎并没有什么问题，递归树还算比较平衡。但是，数组中共有4个2，4个3，但是普通的快速排序为每个2和每个3都分别确定他们的最终位置，这样的操作显然重复了。如何去掉这些重复操作？可以用三路划分的快速排序。<br>在上图中，数组中共有4个2，4个3，如果能一次确定2或3的最终位置就好了。答案是可以的。在经过一次分区后，我们希望arr[low…high]是这样的<br><img src="/quicksort/3way_result.png" title="三路划分"><br>数组的每个元素和pivotValue的大小关系从左到右是&lt;，==和&gt;的，==pivotValue的部分的长度可能不为1。问题是如何达到这个状态。我们可以从五路划分开始，如下图：<br><img src="/quicksort/5way_result.png" title="五路划分"><br>为什么可以使用五路划分？或者说，是怎么想到先五路划分的？首先，我们需要明白，在快速排序的分区过程中：</p><ul><li>左右指针没有相遇前，pivotValue的最终位置无法确定</li><li>分区函数的目的是确定pivotValue最终的位置</li></ul><p>在左右指针没有相遇前，最终位置是无法确定的。我们的目标是划分三路，但是能够划分三路的前提是，我们知道了pivotValue的最终位置。在不知道最终位置之前，我们必须找到一个空间来暂时存储和pivotValue的值。最简单的思路是再开辟一个辅助空间。然而快速排序的最大优势是原地排序+nlog<sub>2</sub>n的时间复杂度，如果另外开辟空间，就不再是原地排序，有点舍本取末。因此，还是尽量的不开辟新空间。这是暂时想不出空间复杂度O(1)的缓存方案，不如从第二点入手：分区函数是确认pivotValue最终的位置。就像上面1.1.所说的，这个位置的值是pivotValue。或者说，只要保证最终位置的值是pivotValue就行了，至于其他位置的值是多少可以不用管。因此，其他位置的数据在不损失的条件下是可以操作的，也就是说可以交换。因此，缓存方案就出来了：随机区域的左边，如果遇上和pivotValue相等的值，那就将其放置在表头；随机区域的右边，如果遇上和pivotValue相等的值，就将其放在表尾。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (p &lt; q) &#123;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; q &amp;&amp; arr[q] &gt;= pivotValue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[q] == pivotValue) &#123;</span><br><span class="line">            swap(arr, j, q);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        q--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; q &amp;&amp; arr[p] &lt;= pivotValue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[p] == pivotValue) &#123;</span><br><span class="line">            swap(arr, i, p);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr[p] == pivotValue) &#123;</span><br><span class="line">    p--;</span><br><span class="line">    q++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>需要注意的是退出循环后p == q，arr[p]和pivotValue的大小关系是不能确定的。如果arr[p] == pivotValue，那p--一次，q++一次就OK了。否则不做任何操作，这是为五路化为三路打好基础。<br>因此这份代码结束后，arr可能是两种情况：<br><img src="/quicksort/4way_result_1.png" title="五路划分的结果1"><br><img src="/quicksort/4way_result_2.png" title="五路划分的结果2"><br>第一张图代表arr[p] != pivotValue 的情况，此时p，q指针不必移动；<br>第二张图代表arr[p] == pivotValue 的情况，此时p，q指针分别需递减和递增一次。</p><p>因为表头表尾都是和pivotValue相等的值，而且pivotValue的最终位置已经确认(p所指向的位置)，所以可以：</p><ul><li>i，p指针所指向的位置交换，同时一起递减，直至i ≥ low</li><li>j，q指针所指向的位置交换，同时一起递增，直至j ≤ high</li></ul><p>所以代码出来了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &gt; low) &#123;</span><br><span class="line">    swap(arr, i - <span class="number">1</span>, p);</span><br><span class="line">    p--;</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j &lt; high) &#123;</span><br><span class="line">    swap(arr, j + <span class="number">1</span>, q);</span><br><span class="line">    q++;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>需要注意一点的是，在交换的时候，i(j)需要减(加)1，这是因为：在发现和pivotValue相等的元素时，是和i(j)的位置交换后，在i++(j--)的，因此i(j)和等于pivotValue的位置是错开一格的，因此i(j)需要减(加)1。</p><p>此时就能从五路转化成三路。此时arr[p…q]都等于pivotValue。<br>完整代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] partition3(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = high;</span><br><span class="line">    <span class="keyword">int</span> p = low;</span><br><span class="line">    <span class="keyword">int</span> q = high;</span><br><span class="line">    <span class="keyword">int</span> pivotValue = arr[low];</span><br><span class="line">    <span class="keyword">while</span> (p &lt; q) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; q &amp;&amp; arr[q] &gt;= pivotValue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[q] == pivotValue) &#123;</span><br><span class="line">                swap(arr, j, q);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            q--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; q &amp;&amp; arr[p] &lt;= pivotValue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[p] == pivotValue) &#123;</span><br><span class="line">                swap(arr, i, p);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[p] == pivotValue) &#123;</span><br><span class="line">        p--;</span><br><span class="line">        q++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; low) &#123;</span><br><span class="line">        swap(arr, i - <span class="number">1</span>, p);</span><br><span class="line">        p--;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; high) &#123;</span><br><span class="line">        swap(arr, j + <span class="number">1</span>, q);</span><br><span class="line">        q++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;p + <span class="number">1</span>, q - <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还是要啰嗦一下，因为边界条件非常重要：最后返回的时候返回的是「new int[]{p + 1, q - 1}」，p(q)是加(减)1后返回的。因为在最后五路归三路的时候，是先交换在p--(q++)的。因此会错开一位，道理跟上面的i(j)是一样的。</p><h2 id="三、基本有序下数组下的快排"><a href="#三、基本有序下数组下的快排" class="headerlink" title="三、基本有序下数组下的快排"></a>三、基本有序下数组下的快排</h2><p>还是从快排的核心——分区函数入手。在完全有序的情况下，时间频度T(n)为：<br>T(n) = T(n -1) + T(1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= T(n -2) + 2 * T(1) + n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= T(n -3) + 3 * T(1) + n + (n - 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;… …<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= T(1) + (n - 1) * T(1) + n + (n - 1) + … + 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= n * T(1) + n + (n - 1) + … + 2 + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= n * T(1) + n<sup>2</sup>/2 + n/2<br>因此，在基本有序的情况下，时间频度T(n)是接近于n * T(1) + n<sup>2</sup>/2 + n/2(T(1)为常数)的。此时递归树极度不平衡。<br>因此在基本有序的数组下，快速排序的性能是十分差的。因此，在数据基本有序的情况下，使用插入排序更好。<br>顺便提一下，插入排序的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i - <span class="number">1</span>] &gt; arr[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = arr[i];</span><br><span class="line">            arr[i] = arr[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; t &lt; arr[j]; j--) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + <span class="number">1</span>] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当数据基本有序时，可以近似认为，插入排序只是把待排数据扫描一遍而已。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>快速排序是一个时间复杂度为O(nlog<sub>2</sub>n)的原地排序。它是的基本原理是确认每轮任意选定一个支点pivot的最终的位置，然后对支点两边的进行相同的操作，逐渐靠近直至到达有序状态。数组应当随机顺序，这样才能保证快速排序的最佳性能，否则可以考虑使用插入排序。倘若遇到重复率较高的随机顺序数组，可以考虑使用三路划分的快速排序来提升排序速度。</p><h2 id="五、感想"><a href="#五、感想" class="headerlink" title="五、感想"></a>五、感想</h2><p>因为之前有简单了研究过，所以这篇文章写的很快，一天就出来了。之前研究的时候，发现快速排序简洁代码的背后蕴含着很多信息，教材给出的代码也只适用于pivot=low的情况，后来我改进了一下，pivot可以任意选，然后就顺手实验一下不同的pivot对快速排序的时间性能影响。通过研究快速排序的机会，我知道了对于排序算法，边界条件很重要，否则很有可能造成数组越界，在递归的情况下也可能造成栈溢出。还有就是任何算法都要在草稿纸上写写画画，这样才能更容易理解其中的原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/quicksort/quicksort_cover.jpeg&quot; title=&quot;cover&quot;&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;快速排序，就像它的名字一样，它做排序很快，空间复杂度O(1)下，它的平均时间复杂度为O(nlog&lt;sub&gt;2&lt;/sub&gt;n)。但是在某些情况下，快速排序不快了，表现出来的性能和冒泡排序排序这类时间复杂度为O(n&lt;sup&gt;2&lt;/sup&gt;)相差无几。因此，本文将解决：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速排序的工作原理&lt;/li&gt;
&lt;li&gt;重复元素下的快排&lt;/li&gt;
&lt;li&gt;基本有序下数组下的快排&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="www.zspirytus.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized的正确食用方法</title>
    <link href="www.zspirytus.com/synchronizedObjects/"/>
    <id>www.zspirytus.com/synchronizedObjects/</id>
    <published>2018-07-18T04:27:13.000Z</published>
    <updated>2018-10-02T18:24:13.842Z</updated>
    
    <content type="html"><![CDATA[<img src="/synchronizedObjects/synchronized_objects_cover.jpeg" title="cover"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面的博客<a href="http://www.zspirytus.com/2018/07/13/aboutSynchronized/">《浅谈synchronized的实现原理》</a>谈到synchronized的实现原理，简单而言就是锁住了对象。但是似乎还比较抽象，本篇博客将解决：</p><ul><li>synchronized锁住的是哪个对象？</li><li>如何合理使用synchronized？<br>那么开始吧。<a id="more"></a></li></ul><h2 id="一、synchronized的两种用法"><a href="#一、synchronized的两种用法" class="headerlink" title="一、synchronized的两种用法"></a>一、synchronized的两种用法</h2><p>synchronized有两种基本用法说起，分别是同步语句块和同步方法。</p><h3 id="1-1-同步语句块"><a href="#1-1-同步语句块" class="headerlink" title="1.1.同步语句块"></a>1.1.同步语句块</h3><p>同步语句块是指被synchronized修饰的语句块，被synchronized修饰的语句块，被多个线程执行的过程是互斥的。同步语句块的写法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synchronizedStatement</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">        <span class="comment">//do Something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>同步语句块锁住的是括号中的对象，上例中锁住的是obj。这个例子是可以编译通过并且正常运行的，说明synchronized能够锁住<em>任意对象</em>。我们可以粗略的把<em>任意对象</em>分为<em>本类的实例对象</em>、<em>本类的类对象</em>以及其他普通对象。</p><h4 id="1-1-1-本类的实例对象"><a href="#1-1-1-本类的实例对象" class="headerlink" title="1.1.1.本类的实例对象"></a>1.1.1.本类的实例对象</h4><p>demo：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synchronizedStatement</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="comment">//do Something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这里，synchronized锁住的是<em>本类的实例对象</em>，需要注意的是：除非本类是单例，否则本类的实例对象在内存中是可以存在有多个的。</p><h4 id="1-1-2-本类的类对象"><a href="#1-1-2-本类的类对象" class="headerlink" title="1.1.2.本类的类对象"></a>1.1.2.本类的类对象</h4><p>demo：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synchronizedStatement</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SomeClass.class)&#123;</span><br><span class="line">        <span class="comment">// do Something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这里，synchronized锁住的是<em>本类的类对象</em>，对象SomeClass.class的类型是Class，本类的类对象在内存中<em>有且仅有一个</em>，因此可以把它看做是单例的。</p><h4 id="1-1-3-其他普通对象"><a href="#1-1-3-其他普通对象" class="headerlink" title="1.1.3.其他普通对象"></a>1.1.3.其他普通对象</h4><p>demo：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synchronizedStatement</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">        <span class="comment">// do Something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这里synchronized锁住的是除了以上提到的任意对象。这个对象的类型可以是HashMap、Integer等API自带类型，也可以是自己编写的类的实例对象、类对象等等。</p><h3 id="1-2-同步方法"><a href="#1-2-同步方法" class="headerlink" title="1.2.同步方法"></a>1.2.同步方法</h3><p>同步方法是指被synchronized修饰的方法，同步方法使得多个线程调用该方法的过程是互斥的。同步方法可以分为静态同步方法和非静态同步方法，锁住的对象是不同的。普通的同步方法锁住的对象是<em>本类的实例对象</em>；而静态同步方法锁住的对象是<em>本类的类对象</em>。以下是两种同步方法的写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Static Synchronized Method</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">staticSynchronizedMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Synchronized Method</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、同步方法和同步语句块的联系"><a href="#二、同步方法和同步语句块的联系" class="headerlink" title="二、同步方法和同步语句块的联系"></a>二、同步方法和同步语句块的联系</h2><p>从上面的解释可以看出，同步方法和同步语句块存在一些联系。事实上，从被锁住的对象的角度来看，synchronized(this)和同步方法是等价的；synchronized(SomeClass.class)和静态同步方法是等价的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两种同步是等价的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两种同步是等价的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addByMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SomeClass.class)&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三、同步与死锁"><a href="#三、同步与死锁" class="headerlink" title="三、同步与死锁"></a>三、同步与死锁</h2><p>同步是互斥的，我们可以简单的认为：我在用，其他人不能用；其他人在用，我不能用。一个经典的例子是：<del>哲♂学家</del>哲学家进餐问题。哲学家问题描述的是经过一系列同步操作后引发死锁的悲剧。因此同步可能会把我们往危险的陷阱——死锁那里带，在同步时我们必须要考虑死锁的情况。</p><h2 id="四、考虑死锁的情况"><a href="#四、考虑死锁的情况" class="headerlink" title="四、考虑死锁的情况"></a>四、考虑死锁的情况</h2><h3 id="4-1-synchronized可能发生死锁吗？"><a href="#4-1-synchronized可能发生死锁吗？" class="headerlink" title="4.1.synchronized可能发生死锁吗？"></a>4.1.synchronized可能发生死锁吗？</h3><p>synchronized锁是同步锁，它能够使得共享数据被多个线程操作前后保持数据一致性。既然是共享数据，就有可能会发生死锁。死锁发生的必要条件是：<br><blockquote><ul><li>互斥条件：进程对所分配到的资源进行排他性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其他进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放。</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其他进程占有，此时请求进程阻塞，但又对自己已获得的其他资源保持不放。</li><li>不剥夺条件：进程已获得的资源，在未使用完成之前，不能被剥夺，只能在使用完毕由其释放。</li><li>环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链，即进程集合P={P<sub>1</sub>,P<sub>2</sub>,… …,P<sub>n</sub>}中的P<sub>1</sub>等待P<sub>2</sub>的资源，P<sub>2</sub>等待P<sub>3</sub>的资源,… …,P<sub>n</sub>等待P<sub>1</sub>的资源。</li></ul><footer><strong>-</strong><cite><a href="https://book.douban.com/subject/26079463/" target="_blank" rel="noopener">《计算机操作系统》</a></cite></footer></blockquote><br>结合synchronized，我们分别考虑这四个条件：<br>1.对于互斥条件：synchronized是同步锁，多个线程竞争执行同步代码时，有且仅有一个线程获得锁，因此互斥条件是必然满足的。<br>2.对于请求和保持条件：因为同步方法和同步语句块原理相同，因此在这里考虑同步语句块。请求和保持，意味着每一个线程至少需要两个不同的锁，即同步语句块中嵌入同步语句块，并且锁的对象是不同的，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object_1)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(object_2)&#123;</span><br><span class="line">        <span class="comment">// do something synchronized or obtain other monitor lock</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这个例子中，如果线程获得object_1的对象锁，但是因object_2的对象锁被其他线程持有，因此它会被阻塞并保持持有object_1的对象锁。因此，请求和保持条件是可满足的。<br>3.不剥夺条件：如请求保持条件，直到线程获取全部需要的对象锁并执行完同步语句块，它是不会释放它获得的锁的。synchronized并没有强制剥夺某一个线程拥有锁的机制，因此，在没有人为的情况下，不剥夺条件必然满足。<br>4.假设请求和保持条件满足，并结合互斥条件和不剥夺条件。对于环路等待条件满足的情况下，情况就会这这样的，线程们都获得了至少一个锁并且都保持，并且任意一个线程，需要其他线程已经获得的锁（请求保持）。于是大家都和和气气地（不剥夺条件）互相等待。然后就成环了。接下来看一段简单的代码，这段代码实现的是线程t<sub>1</sub>和t<sub>2</sub>共同竞争object_1和object_2的对象锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String THREAD_1 = <span class="string">"Thread 1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String THREAD_2 = <span class="string">"Thread 2"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object_1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> Object object_2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, IllegalMonitorStateException </span>&#123;</span><br><span class="line">        Logcat(<span class="string">"try to get object_1's lock!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (object_1) &#123;</span><br><span class="line">            Logcat(<span class="string">"get object_1's lock!"</span>);</span><br><span class="line">            Logcat(<span class="string">"Sleeping ... ..."</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            Logcat(<span class="string">"wake up! try to get object_2's lock!"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (object_2) &#123;</span><br><span class="line">                Logcat(<span class="string">"get object_2's lock!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, IllegalMonitorStateException </span>&#123;</span><br><span class="line">        Logcat(<span class="string">"try to get object_2's lock!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (object_2) &#123;</span><br><span class="line">            Logcat(<span class="string">"get object_2's lock!"</span>);</span><br><span class="line">            Logcat(<span class="string">"try to get object_1's lock!"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (object_1) &#123;</span><br><span class="line">                Logcat(<span class="string">"get object_1's lock!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Logcat</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> DeadLockTest deadLockTest = <span class="keyword">new</span> DeadLockTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                deadLockTest.methodA();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalMonitorStateException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                deadLockTest.methodB();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalMonitorStateException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.setName(THREAD_1);</span><br><span class="line">        t2.setName(THREAD_2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        Logcat(<span class="string">"Finish Successfully!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Thread 1: try to get object_1's lock!</span></span><br><span class="line"><span class="comment">// Thread 1: get object_1's lock!</span></span><br><span class="line"><span class="comment">// Thread 1: Sleeping ... ...</span></span><br><span class="line"><span class="comment">// Thread 2: try to get object_2's lock!</span></span><br><span class="line"><span class="comment">// Thread 2: get object_2's lock!</span></span><br><span class="line"><span class="comment">// Thread 2: try to get object_1's lock!</span></span><br><span class="line"><span class="comment">// Thread 1: wake up! try to get object_2's lock!</span></span><br></pre></td></tr></table></figure><br>这段代码大概率会出现死锁。发生死锁时，输出如62~68行。代码的执行顺序是不确定的，但是从这个例子的输出来看，要发生死锁，必然存在子顺序：<br>1.t<sub>1</sub>获得object_1的对象锁<br>2.t<sub>2</sub>获得object_2的对象锁<br>3.JVM去执行其他调度，这里就用休眠操作来模拟<br>4.t<sub>1</sub>尝试获取object_2的对象锁，但已被占用，阻塞。<br>5.t<sub>2</sub>尝试获取object_1的对象锁，但已被占用，阻塞。<br>这里就是环路等待的情况了！t<sub>1</sub>等t<sub>2</sub>，t<sub>2</sub>等t<sub>1</sub>，除非人为干预，否则永远持续。<br>从上面来看，使用synchronized是有可能发生死锁的！因为四个条件的合取并不恒为假。因此在使用时要慎重考虑，因为一旦发生死锁，程序就死掉。</p><h3 id="4-2-死锁的避免"><a href="#4-2-死锁的避免" class="headerlink" title="4.2.死锁的避免"></a>4.2.死锁的避免</h3><p>死锁的发生是有条件的。为了避免发生死锁，我们只需要破坏条件，使其不满足即可。分别考虑四个条件：<br>1.互斥条件。互斥条件必然满足的，破坏是不可能破坏的。<br>2.请求等待条件、不剥夺条件和环路等待条件互相配合。在请求等待时，线程至少持有一个对象锁。如果发生死锁时，通过破坏不剥夺条件和环路等待条件，有不多于[线程个数 - 共享资源个数]个线程主动释放当前持有的锁，那么尴尬的局面就可以缓解。为什么是不多于[线程个数 - 共享资源个数]个线程而不是全部线程？以<del>哲♂学家</del>哲学家进餐问题为例，考虑情况：所有哲学家都饿了，然后他们同时拿到左边的筷子。这个时候他们同时wait()，放下左边的筷子(释放资源)，并等待通知其他哲学家用完的通知(notify())。然而，从上帝视角来看，情况是这样的：所有哲学家先同时拿起左边的筷子，然后发现不对，然后全部放下左边的筷子，然后等，最后饿死。<br>这里的线程个数为2，共享资源个数为1，因为对于任意两个相邻的哲学家，他们会竞争1根筷子。因此，在这个例子中，当发生死锁时，任意一对相邻的哲学家，只要有[2 - 1]个哲学家放弃筷子，这时候死锁就能解除。因此，上面会发生死锁的代码可以如下改进：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String THREAD_1 = <span class="string">"Thread 1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String THREAD_2 = <span class="string">"Thread 2"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object_1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> Object object_2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isObject1Locked = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isObject2Wait = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, IllegalMonitorStateException </span>&#123;</span><br><span class="line">        Logcat(<span class="string">"try to get object_1's lock!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (object_1) &#123;</span><br><span class="line">            isObject1Locked = <span class="keyword">true</span>;</span><br><span class="line">            Logcat(<span class="string">"get object_1's lock!"</span>);</span><br><span class="line">            Logcat(<span class="string">"Sleeping ... ..."</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            Logcat(<span class="string">"wake up! try to get object_2's lock!"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (object_2) &#123;</span><br><span class="line">                Logcat(<span class="string">"get object_2's lock!"</span>);</span><br><span class="line">                <span class="keyword">if</span> (isObject2Wait) &#123;</span><br><span class="line">                    Logcat(<span class="string">"I will finish, notify!"</span>);</span><br><span class="line">                    object_2.notify();</span><br><span class="line">                    isObject2Wait = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isObject1Locked = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, IllegalMonitorStateException </span>&#123;</span><br><span class="line">        Logcat(<span class="string">"try to get object_2's lock!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (object_2) &#123;</span><br><span class="line">            Logcat(<span class="string">"get object_2's lock!"</span>);</span><br><span class="line">            Logcat(<span class="string">"try to get object_1's lock!"</span>);</span><br><span class="line">            <span class="keyword">if</span> (isObject1Locked) &#123;</span><br><span class="line">                isObject2Wait = <span class="keyword">true</span>;</span><br><span class="line">                object_2.wait();</span><br><span class="line">                Logcat(<span class="string">"Fortunately, object_1 is locked, release object_2's lock and wait!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (object_1) &#123;</span><br><span class="line">                isObject1Locked = <span class="keyword">true</span>;</span><br><span class="line">                Logcat(<span class="string">"get object_1's lock!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            isObject1Locked = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Logcat</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> DeadLockTest deadLockTest = <span class="keyword">new</span> DeadLockTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                deadLockTest.methodA();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalMonitorStateException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                deadLockTest.methodB();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalMonitorStateException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.setName(THREAD_1);</span><br><span class="line">        t2.setName(THREAD_2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        Logcat(<span class="string">"Finish Successfully!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Thread 1: try to get object_1's lock!</span></span><br><span class="line"><span class="comment">// Thread 2: try to get object_2's lock!</span></span><br><span class="line"><span class="comment">// Thread 1: get object_1's lock!</span></span><br><span class="line"><span class="comment">// Thread 2: get object_2's lock!</span></span><br><span class="line"><span class="comment">// Thread 2: try to get object_1's lock!</span></span><br><span class="line"><span class="comment">// Thread 1: Sleeping ... ...</span></span><br><span class="line"><span class="comment">// Thread 1: wake up! try to get object_2's lock!</span></span><br><span class="line"><span class="comment">// Thread 1: get object_2's lock!</span></span><br><span class="line"><span class="comment">// Thread 1: I will finish, notify!</span></span><br><span class="line"><span class="comment">// Thread 2: Fortunately, object_1 is locked, release object_2's lock and wait!</span></span><br><span class="line"><span class="comment">// Thread 2: get object_1's lock!</span></span><br><span class="line"><span class="comment">// main: Finish Successfully!</span></span><br></pre></td></tr></table></figure></p><p>这段代码的原理是：<br>2.1.当线程t<sub>2</sub>准备获取object_1的对象锁时，如果object_1已被锁住则放弃当前持有的object_2锁；<br>2.2.当线程t<sub>1</sub>将要释放object_2的对象锁时，如果t<sub>1</sub>处于等待状态，则通知它准备。</p><h2 id="五、题外话：不够用？试试ReetrantLock！"><a href="#五、题外话：不够用？试试ReetrantLock！" class="headerlink" title="五、题外话：不够用？试试ReetrantLock！"></a>五、题外话：不够用？试试ReetrantLock！</h2><p>ReetrantLock在Java8 api docs中是被这么描述的：<br><blockquote><p>A reentrant mutual exclusion Lock with the same basic behavior and semantics as the implicit monitor lock accessed using synchronized methods and statements, but with extended capabilities.</p></blockquote><br>一个与基于monitor锁实现的同步方法或同步语句块有相同的行为和语义的可重入互斥锁，并具有扩展功能。<br>一个简单的demo：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>同步前只需要调用ReentrantLock.lock()锁住，使用完毕一定要解锁。为了增加可读性，可使用try…finally结构。<br>ReentrantLock的功能不仅限于此，它提供尝试获得锁，失败就放弃的功能，demo如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">             i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">": failed to get lock!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lock.isHeldByCurrentThread())&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>lock.tryLock(1, TimeUnit.SECONDS) 表示尝试获得锁，如果超过一秒还没能获得锁则放弃获得并退出，不会重试。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>synchronized锁住的是哪个对象？<br>对于同步语句块，synchronized锁住的是括号中的对象。对于同步方法，静态同步方法中synchronized锁住的是<em>本类的类对象</em>，而普通同步方法中的synchronized锁住的是<em>本类的实例对象</em></li><li>如何合理使用synchronized？<br>synchronized是同步的，互斥的。在使用的时候必须考虑死锁的情况。通过考察发生死锁的四个必要条件，然后逐一破坏（互斥条件的破坏是不可能的），避免死锁的发生。在复杂的场景，可以考虑使用ReentrantLock。</li></ul><h2 id="七、感想"><a href="#七、感想" class="headerlink" title="七、感想"></a>七、感想</h2><p>在明白原理的前提下，很多问题都能通过原理来得到解答。我第一次接触synchronized的时候，以为它锁的是代码块。然而明白原理后，不仅明白了锁的是对象，而且还明白了锁哪个对象，有什么区别。这是我对于本文的前半部分的感想。重点是死锁的部分，我翻了很多资料，包括大二的操作系统教材。在第一次学同步互斥的时候是一脸懵逼的，感觉难就简单的记一记背一背，没有理解。通过这次写博客的机会，我琢磨了好久，反反复复看死锁那章，终于理解了。相比死记硬背，理解后更能举一反三，融会贯通。所以看这种原理性的书还是要耐心，理解才好。还有，在查资料的过程中发现有很多名词，像多叉树一样互相联系着，感觉自己还有很多不懂，Java这条路还是任重道远。暂时就这么多，就这样吧。水平有限，如果本文有误，还望指正，谢谢~</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/synchronizedObjects/synchronized_objects_cover.jpeg&quot; title=&quot;cover&quot;&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前面的博客&lt;a href=&quot;http://www.zspirytus.com/2018/07/13/aboutSynchronized/&quot;&gt;《浅谈synchronized的实现原理》&lt;/a&gt;谈到synchronized的实现原理，简单而言就是锁住了对象。但是似乎还比较抽象，本篇博客将解决：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;synchronized锁住的是哪个对象？&lt;/li&gt;
&lt;li&gt;如何合理使用synchronized？&lt;br&gt;那么开始吧。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="www.zspirytus.com/tags/Java/"/>
    
      <category term="多线程" scheme="www.zspirytus.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>浅谈synchronized的实现原理</title>
    <link href="www.zspirytus.com/aboutSynchronized/"/>
    <id>www.zspirytus.com/aboutSynchronized/</id>
    <published>2018-07-13T12:15:12.000Z</published>
    <updated>2018-11-26T15:42:28.148Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/aboutSynchronized/about_synchronized_cover.jpeg" alt="cover"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Synchronized是Java中的重量级锁，在我刚学Java多线程编程时，我只知道它的实现和monitor有关，但是synchronized和monitor的关系，以及monitor的本质究竟是什么，我并没有尝试理解，而是选择简单的略过。在最近的一段时间，由于实际的需要，我又把这个问题翻出来，Google了很多资料，整个实现的过程总算是弄懂了，为了以防遗忘，便整理成了这篇博客。<br>在本篇博客中，我将以class文件为突破口，试图解释Synchronized的实现原理。<br><a id="more"></a></p><h2 id="从java代码的反汇编说起"><a href="#从java代码的反汇编说起" class="headerlink" title="从java代码的反汇编说起"></a>从java代码的反汇编说起</h2><p>很容易的想到，可以从<em>程序的行为</em>来了解synchronized的实现原理。但是在源代码层面，似乎看不出synchronized的实现原理。锁与不锁的区别，似乎仅仅只是有没有被synchronized修饰。不如把目光放到更加底层的汇编上，看看能不能找到突破口。<em>javap</em>是官方提供的*.class文件分解器，它能帮助我们获取*.class文件的汇编代码。具体用法可参考<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javap.html" target="_blank" rel="noopener">这里</a>。 接下来我会使用javap命令对*.class文件进行反汇编。<br>编写文件Test.java:<br><figure class="highlight java"><figcaption><span>Test.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addI_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">addI_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>生成class文件，并获取对Test.class反汇编的结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Test.java</span><br><span class="line">javap -v Test.class</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/zhangkunwei/Desktop/Test.class</span><br><span class="line">  Last modified Jul 13， 2018; size 453 bytes</span><br><span class="line">  MD5 checksum ada74ec8231c64230d6ae133fee5dd16</span><br><span class="line">  Compiled from &quot;Test.java&quot;</span><br><span class="line">  ... ...</span><br><span class="line">  public void addI_1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3， locals=3， args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: dup</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: monitorenter</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: dup</span><br><span class="line">         6: getfield      #2                  // Field i:I</span><br><span class="line">         9: iconst_1</span><br><span class="line">        10: iadd</span><br><span class="line">        11: putfield      #2                  // Field i:I</span><br><span class="line">        14: aload_1</span><br><span class="line">        15: monitorexit</span><br><span class="line">        16: goto          24</span><br><span class="line">        19: astore_2</span><br><span class="line">        20: aload_1</span><br><span class="line">        21: monitorexit</span><br><span class="line">        22: aload_2</span><br><span class="line">        23: athrow</span><br><span class="line">        24: return</span><br><span class="line">  ... ...</span><br><span class="line">    public synchronized void addI_2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC， ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=3， locals=1， args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: dup</span><br><span class="line">         2: getfield      #2                  // Field i:I</span><br><span class="line">         5: iconst_1</span><br><span class="line">         6: iadd</span><br><span class="line">         7: putfield      #2                  // Field i:I</span><br><span class="line">        10: return</span><br><span class="line">   ... ...</span><br></pre></td></tr></table></figure><p>通过反汇编结果，我们可以看到：</p><ul><li>进入被synchronized修饰的语句块时会执行<strong>monitorenter</strong>，离开时会执行<strong>monitorexit</strong>。</li><li>相较于被synchronized修饰的语句块，被synchronized修饰的方法中没有指令<strong>monitorenter</strong>和<strong>monitorexit</strong>，且flags中多了ACC_SYNCHRONIZED标志。<br><strong>monitorenter</strong>和<strong>monitorexit</strong>指令是做什么的？同步语句块和同步方法的实现原理有何不同？遇事不决查文档，看看官方文档的解释。</li></ul><h3 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h3><blockquote><p><strong>Description</strong><br>The <em>objectref</em> must be of type <em>reference</em>.</p><p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with <em>objectref</em>， as follows:</p><ul><li><p>If the entry count of the monitor associated with <em>objectref</em> is zero， the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.</p></li><li><p>If the thread already owns the monitor associated with <em>objectref</em>， it reenters the monitor， incrementing its entry count.</p></li><li><p>If another thread already owns the monitor associated with <em>objectref</em>， the thread blocks until the monitor’s entry count is zero， then tries again to gain ownership.</p></li></ul><p><strong>Notes</strong></p><ul><li>A monitorenter instruction may be used with one or more monitorexit instructions (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit" target="_blank" rel="noopener">§monitorexit</a>) to implement a synchronized statement in the Java programming language (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.14" target="_blank" rel="noopener">§3.14</a>). The monitorenter and monitorexit instructions are not used in the implementation of synchronized methods， although they can be used to provide equivalent locking semantics. Monitor entry on invocation of a synchronized method， and monitor exit on its return， are handled implicitly by the Java Virtual Machine’s method invocation and return instructions， as if monitorenter and monitorexit were used.</li></ul><footer><strong>Java Virtual Machine Specification -</strong><cite><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter" target="_blank" rel="noopener">monitorenter</a></cite></footer></blockquote><p>简单翻译一下:<br>指令<strong>monitorenter</strong>的操作的必须是一个对象的引用，且其类型为引用。每一个对象都会有一个<strong>monitor</strong>与之关联，当且仅当<strong>monitor</strong>被(其他(线程)对象)持有时，<strong>monitor</strong>会被锁上。其执行细节是，当一个线程尝试持有某个对象的<strong>monitor</strong>时：</p><ul><li>如果该对象的<strong>monitor</strong>中的<strong>entry count</strong>==0，则将<strong>entry count</strong>置1，并令该线程为<strong>monitor</strong>的持有者。</li><li>如果该线程已经是该对象的<strong>monitor</strong>的持有者，那么重新进入<strong>monitor</strong>，并使得<strong>entry count</strong>自增一次。</li><li>如果其他线程已经持有该对象的<strong>monitor</strong>，则该线程将会被阻塞，直到<strong>monitor</strong>中的<strong>entry count</strong>==0，然后重新尝试持有。<br>注意:<br><strong>monitorenter</strong>必须与一个以上<strong>monitorexit</strong>配合使用来实现Java中的同步语句块。而同步方法却不是这样的:同步方法不使用<strong>monitorenter</strong>和<strong>monitorexit</strong>来实现。当同步方法被调用时，<strong>Monitor</strong>介入；当同步方法return时，<strong>Monitor</strong>退出。这两个操作，都是被<strong>JVM</strong>隐式的handle的，就好像这两个指令被执行了一样。</li></ul><h3 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h3><blockquote><p><strong>Description</strong></p><ul><li><p>The <em>objectref</em> must be of type <em>reference</em>.</p></li><li><p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by <em>objectref</em>.</p></li><li><p>The thread decrements the entry count of the monitor associated with <em>objectref</em>. If as a result the value of the entry count is zero， the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p></li></ul><footer><strong>Java Virtual Machine Specification -</strong><cite><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit" target="_blank" rel="noopener">monitorexit</a></cite></footer></blockquote><p>简单翻译一下:<br>指令<strong>monitorenter</strong>的操作的必须是一个对象的引用，且其类型为引用。并且：</p><ul><li>执行<strong>monitorexit</strong>的线程必须是<strong>monitor</strong>的持有者。</li><li>执行<strong>monitorexit</strong>的线程让<strong>monitor</strong>的<strong>entry count</strong>自减一次。如果最后<strong>entry count</strong>==0，这个线程就不再是<strong>monitor</strong>的持有者，意味着其他被阻塞线程都能够尝试持有<strong>monitor</strong></li></ul><p>根据以上信息，上面的疑问得到了解释：<br>1.<strong>monitorenter</strong>和<strong>monitorexit</strong>是做什么的？<br><strong>monitorenter</strong>能“锁住”对象。当一个线程获取<strong>monitor</strong>的锁时，其他请求访问共享内存空间的线程无法取得访问权而被阻塞；<strong>monitorexit</strong>能“解锁”对象，唤醒因没有取得共享内存空间访问权而被阻塞的线程。</p><p>2.为什么一个<strong>monitorenter</strong>与多个<strong>monitorexit</strong>对应，是一对多，而不是一一对应？<br>一对多的原因，是为了保证：执行<strong>monitorenter</strong>指令，后面一定会有一个<strong>monitorexit</strong>指令被执行。上面的例子中，程序正常执行，在离开同步语句块时执行第一个<strong>monitorexit</strong>；Runtime期间程序抛出Exception或Error，而后执行第二个<strong>monitorexit</strong>以离开同步语句块。</p><p>3.为什么同步语句块和同步方法的反汇编代码略有不同？<br>同步语句块是使用<strong>monitorenter</strong>和<strong>monitorexit</strong>实现的；而同步方法是<strong>JVM</strong>隐式处理的，效果与<strong>monitorenter</strong>和<strong>monitorexit</strong>一样。并且，同步方法的flags也不一样，多了一个ACC_SYNCHRONIZED标志，这个标志是告诉<strong>JVM</strong>：这个方法是一个同步方法，可以参考<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.6-200-A.1" target="_blank" rel="noopener">这里</a>。</p><h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>在上一个部分，我们容易得出一个结论：synchronized的实现和<strong>monitor</strong>有关。<strong>monitor</strong>又是什么呢？从文档的描述可以看出，<strong>monitor</strong>类似于操作系统中的<strong>互斥量</strong>这个概念：不同对象对共享内存空间的访问是互斥的。在<strong>JVM</strong>（<strong>Hotspot</strong>）中，<strong>monitor</strong>是由<strong>ObjectMonitor</strong>实现，其主要的数据结构如下:<br><figure class="highlight c"><figcaption><span>ObjectMonitor</span><a href="https://github.com/JetBrains/jdk8u_hotspot/blob/master/src/share/vm/runtime/objectMonitor.hpp#L140" target="_blank" rel="noopener">ObjectMonitor.hpp</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>;</span><br><span class="line">    _waiters      = <span class="number">0</span>，</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;   <span class="comment">//指向当前monitor的持有者 </span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>;   <span class="comment">//持有monitor后，调用的wait()的线程集合</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ;  <span class="comment">//尝试持有monitor失败后被阻塞的线程集合</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">    _previous_owner_tid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，我们可以</p><ul><li>通过修改_owner来指明<strong>monitor</strong>锁的拥有者；</li><li>通过读取_EntryList来获取因获取锁失败而被阻塞的线程集合；</li><li>通过读取_WaitSet来获取在获得锁后主动放弃锁的线程集合。</li></ul><p>到这里，synchronized的实现原理已经基本理清楚了，但是还有一个未解决的疑问：线程是怎么知道<strong>monitor</strong>的地址的？线程只有知道它的地址，才能够访问它，然后才能与以上的分析联系上。答案是<strong>monitor</strong>的地址在Java对象头中。</p><h2 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h2><p>在Java中，每一个对象的组成成分中都有一个Java对象头。通过对象头，我们可以获取对象的相关信息。<br>这是Java对象头的数据结构(32位虚拟机下):<br><img src="/aboutSynchronized/Java对象头数据结构.png" title="Java对象头数据结构"><br>其中的Mark Word，它是一个可变的数据结构，即它的数据结构是依情况而定的。下面是在对应的锁状态下，Mark Word的数据结构(32位虚拟机下)：<br><img src="/aboutSynchronized/Mark_Word数据结构.png" title="Mark Word数据结构"><br>synchronized是一个重量级锁，所以对应图中的重量级锁状态。其中有一个字段是：指向重量级锁的指针，共占用25+4+1=30bit，它的内容就是这个对象的引用所关联的<strong>monitor</strong>的地址。<br>线程可以通过Java对象头中的Mark Word字段，来获取<strong>monitor</strong>的地址，以便获得锁。</p><h2 id="回到最初的问题"><a href="#回到最初的问题" class="headerlink" title="回到最初的问题"></a>回到最初的问题</h2><p>synchronized的实现原理是什么？从上面的分析来看，答案已经显而易见了。当多个线程一起访问共享内存空间时，这些线程可以通过synchronized锁住<em>对象</em>的对象头中，根据Mark Word字段来访问该对象所关联的<strong>monitor</strong>，并尝试获取。当一个线程成功获取<strong>monitor</strong>后，其他与之竞争<strong>monitor</strong>持有权的线程将会被阻塞，并进入EntryList。当该线程操作完毕后，释放锁，因争用<strong>monitor</strong>失败而被阻塞的线程就会被唤醒，然后重复以上步骤。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>我发现其实大部分答案都可以从文档中得到，所以以后遇到问题还是要尝试从文档中找到答案。<br>本人水平有限，如果本文有错误，还望指正，谢谢~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/aboutSynchronized/about_synchronized_cover.jpeg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Synchronized是Java中的重量级锁，在我刚学Java多线程编程时，我只知道它的实现和monitor有关，但是synchronized和monitor的关系，以及monitor的本质究竟是什么，我并没有尝试理解，而是选择简单的略过。在最近的一段时间，由于实际的需要，我又把这个问题翻出来，Google了很多资料，整个实现的过程总算是弄懂了，为了以防遗忘，便整理成了这篇博客。&lt;br&gt;在本篇博客中，我将以class文件为突破口，试图解释Synchronized的实现原理。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="www.zspirytus.com/tags/Java/"/>
    
      <category term="多线程" scheme="www.zspirytus.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hello World!</title>
    <link href="www.zspirytus.com/HelloWorld/"/>
    <id>www.zspirytus.com/HelloWorld/</id>
    <published>2018-05-21T08:58:40.000Z</published>
    <updated>2018-07-19T16:07:18.786Z</updated>
    
    <content type="html"><![CDATA[<p>Hello World！<br>博客终于搭起来啦！<br>搭博客没有别的目的，只为<strong>输出倒逼输入</strong>，自己给别人讲清楚了，才能对知识的理解更近一步！<br>第一次也不知道该怎么说，就以我第一个编写的程序结尾吧！<br><figure class="highlight c"><figcaption><span>Best Practice</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hello World！&lt;br&gt;博客终于搭起来啦！&lt;br&gt;搭博客没有别的目的，只为&lt;strong&gt;输出倒逼输入&lt;/strong&gt;，自己给别人讲清楚了，才能对知识的理解更近一步！&lt;br&gt;第一次也不知道该怎么说，就以我第一个编写的程序结尾吧！&lt;br&gt;&lt;figure class=
      
    
    </summary>
    
    
  </entry>
  
</feed>
