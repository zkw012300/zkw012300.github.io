<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZSpirytus的博客</title>
  <icon>https://www.gravatar.com/avatar/5427c5380bea56f0a9fb2a5fada097e9</icon>
  <subtitle>这里是ZSpirytus的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.zspirytus.com/"/>
  <updated>2018-10-22T12:00:18.754Z</updated>
  <id>www.zspirytus.com/</id>
  
  <author>
    <name>ZSpirytus</name>
    <email>zhanwel261717@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于深度优先搜索的一点小心得</title>
    <link href="www.zspirytus.com/2018/10/18/DFS/"/>
    <id>www.zspirytus.com/2018/10/18/DFS/</id>
    <published>2018-10-18T02:32:07.000Z</published>
    <updated>2018-10-22T12:00:18.754Z</updated>
    
    <content type="html"><![CDATA[<img src="/18/DFS/2018/10/18/DFS/cover.jpeg"><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>上周刷了20来道LeetCode的题，总结出了一些关于深度优先搜索的小小的心得，于是有了这篇博客。这次的总体思路是：</p><ol><li>深度优先搜索算法的工作过程</li><li>如何使用深度优先搜索算法来进行遍历</li><li>两个有趣的问题</li><li>深度优先搜索算法和循环的关系</li></ol><p>那我们开始吧。</p><a id="more"></a><h2 id="2-深度优先搜索"><a href="#2-深度优先搜索" class="headerlink" title="2. 深度优先搜索"></a>2. 深度优先搜索</h2><p>深度优先搜索（Deep First Search, DFS）是一种先序遍历，先遇到的节点先访问，然后以这个节点为起点，继续向下遍历，直至所有的节点都被访问（连通分量 == 1的情况下）。所以，个人认为，DFS可以看做是一种暴力枚举的算法。多说无益，下面一个例子可能会让你对DFS有初步的了解。<br><img src="/18/DFS/2018/10/18/DFS/SimpleExample.jpg" title="简单的例子"><br>这是一个有向、无环、连通分量为1的图，我们可以用邻接矩阵来存储它：<br><img src="/18/DFS/2018/10/18/DFS/AdjacencyMatrix.jpg" title="邻接矩阵"><br>这个矩阵的意义是，如果<code>graph[i][j] == 1</code>，那么节点i和节点j的关系是<code>i -&gt; j</code>，即有从节点i到节点j的通路。<br>我先不放代码，我先跟着DFS的思路来对上面的图，以节点1为起点深度优先遍历一次。<br>由于是从节点1开始遍历，因此我们先看看数组graph[0][0…5]，从0到5扫一遍，发现graph[0][1]不为零，说明有节点1到节点2的边。由于DFS是先访问，再以此节点为起点继续向下遍历，所以我们先把节点1，节点2存起来，然后以节点2为起点，向下遍历，如下图：<br><img src="/18/DFS/2018/10/18/DFS/SimpleExample_Step1.jpg" title="DFS第一步"><br>接下来，扫一遍<code>graph[1][0...5]</code>，发现<code>graph[1][2]</code>不为0，说明节点2连向节点3，则把节点3存起来，然后以节点3为起点，向下遍历：<br><img src="/18/DFS/2018/10/18/DFS/SimpleExample_Step2.jpg" title="DFS第二步"><br>很好，接下来扫一遍<code>graph[2][0...5]</code>，但是遗憾的是，数组<code>graph[2][0...5]</code>并没有值为1的元素，这表明，节点3没有连向其他节点，即出度为0。因此，这时候需要回溯，回到上一层：<br><img src="/18/DFS/2018/10/18/DFS/SimpleExample_Step3.jpg" title="DFS第三步"><br>这时，上一步已经回溯到了上一层，此时我们需要扫描<code>graph[1][3...5]</code>，此时发现<code>graph[1][3]</code>不为0，说明节点2连向节点4，那么应该把节点4存起来，接下来以节点4为起点继续向下遍历：<br><img src="/18/DFS/2018/10/18/DFS/SimpleExample_Step4.jpg" title="DFS第四步"><br>很好，接下来扫一遍<code>graph[3][0...5]</code>，发现<code>graph[3][4]</code>不为0，说明节点4连向节点5，我们应该把节点5存起来，然后以节点5为起点，向下遍历：<br><img src="/18/DFS/2018/10/18/DFS/SimpleExample_Step5.jpg" title="DFS第五步"><br>此时，我们需要扫描一遍<code>graph[4][0...5]</code>，发现<code>graph[4][5]</code>不为0，说明节点5连向节点6，我们应该把节点6存起来。然后以节点6位节点，向下遍历：<br><img src="/18/DFS/2018/10/18/DFS/SimpleExample_Step6.jpg" title="DFS第六步"><br>然而，<code>graph[5][0...5]</code>并没有不为0的元素，这说明，节点6的出度为0，应该回溯，回到上一层：<br><img src="/18/DFS/2018/10/18/DFS/SimpleExample_Step7.jpg" title="DFS第七步"><br>此时，我们回到了<code>graph[4][0...5]</code>，但是<code>graph[4][0...5]</code>已经扫完了，我们继续回溯，回到<code>graph[4][0...5]</code>的上一层<code>graph[3][5...5]</code>，但是<code>graph[3][5...5]</code>已经没有不为0的元素了，所以我们继续回溯，回到上一层：<br><img src="/18/DFS/2018/10/18/DFS/SimpleExample_Step8.jpg" title="DFS第八步"><br>此时，我们回到了<code>graph[1][4...5]</code>，<code>graph[1][4...5]</code>已经没有不为0的元素了，继续回溯，回到上一层：<br><img src="/18/DFS/2018/10/18/DFS/SimpleExample_Step9.jpg" title="DFS第九步"><br>终于回到<code>graph[0][2...5]</code>了，我们继续扫描，发现<code>graph[0][4]</code>不为0，但是节点5（<code>graph[0][4]</code>的4表示节点5）已经访问过了，我们没必要，也不能继续存节点5了，所以我们忽略<code>graph[0][4]</code>，继续扫描，最后扫描完毕，遍历结束。<br><img src="/18/DFS/2018/10/18/DFS/SimpleExample_Step10.jpg" title="DFS第十步"></p><p>这个过程如果明白了，代码就很容易写出来：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deepFirstSearch</span><span class="params">(<span class="keyword">int</span>[][] graph, List&lt;Integer&gt; result, <span class="keyword">int</span>[] accessFlag, <span class="keyword">int</span> startVertex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startVertex &lt; graph.length) &#123;</span><br><span class="line">        result.add(startVertex + <span class="number">1</span>);</span><br><span class="line">        accessFlag[startVertex] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[startVertex].length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[startVertex][i] == <span class="number">1</span> &amp;&amp; accessFlag[i] != <span class="number">1</span>) &#123;</span><br><span class="line">                deepFirstSearch(graph, result, accessFlag, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>解释一下，for循环对应上面所说的扫描，<code>startVertex</code>是当前的起点。如果<code>graph[startVertex][i]</code>不为0，说明有从startVertex到i的通路，即<code>startVertex -&gt; i</code>，并且如果节点i并未被访问（访问节点i时accessFlag[i]会被置为1），那就以节点i为起点向下遍历；而if语句是为了检查输入数据是否合法。<br>方法已经写好，我们只需要如下调用，就能拿到DFS的结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">deepFirstSearch(graph, result, <span class="keyword">new</span> <span class="keyword">int</span>[graph.length], <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>总结一下，DFS就是先遇到先访问，再以此为起点继续访问，直至全部访问完毕，很像先序遍历。</p><h2 id="3-DFS应该怎么用来遍历？"><a href="#3-DFS应该怎么用来遍历？" class="headerlink" title="3. DFS应该怎么用来遍历？"></a>3. DFS应该怎么用来遍历？</h2><p>通过上面的说明，想必已经对DFS有初步的理解了吧。那我们继续吧。<br>前面我已经说过，DFS可以看做是一种暴力枚举算法。结合上面的例子，我们可以看到，邻接矩阵graph的所有元素都被DFS算法扫描了一遍，所以至少从这个例子来看DFS是一种暴力枚举算法。我认为确实也是。<br>OK，既然我们已经知道DFS可以看做一种暴力枚举算法，我们应该怎么用它来枚举？在这里，我想通过分析二叉树的先序遍历过程乃至多叉树的遍历过程，进而推广到一般的情况来说明。</p><p>首先定义一下树的数据结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Tree leftChild;</span><br><span class="line">    Tree rightChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>自然地，该二叉树的先序遍历就可以这么写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderTraversal</span><span class="params">(Tree parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="keyword">null</span>) &#123;</span><br><span class="line">        accessTreeVertex(parent);</span><br><span class="line">        preOrderTraversal(parent.leftChild);</span><br><span class="line">        preOrderTraversal(parent.rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>二叉树的遍历如何推广到多叉树的遍历？如果可以用for循环将这个节点的所有孩子节点列举出来那就好了。确实可以。我们只需要稍微改写一下数据结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Tree children[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后如下遍历：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderTraversal</span><span class="params">(Tree parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="keyword">null</span>) &#123;</span><br><span class="line">        accessTreeVertex(parent);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parent.children.length; i++) &#123;</span><br><span class="line">            preOrderTraversal(tree.children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为什么要这么写，这段代码背后的思路是什么？<br>如果<code>children.length == 2</code>那就是二叉树的情形。自然地，如果<code>children.length</code>为任意值，那就是任意多叉树的情形，即可以对任意多叉树进行遍历。其实思路就是将孩子节点转化成可以被for循环列举的形式（如上面是把孩子节点转成数组）。<br>现在，我们看看多叉树的子结构：<br><img src="/18/DFS/2018/10/18/DFS/APartOfTree.jpg" title="多叉树子结构"><br>这个多叉树的子结构，是一个父节点带着n个子节点(n是任意一个大于0的整数)的结构。我们如何对这个子结构进行遍历？</p><ol><li>首先我们访问父节点，即<code>accessVertex(parent)</code></li><li>因为父节点有n个子节点，所以我们挨个的访问它们。由于孩子节点存在数组中，于是我们可以用for循环解决。</li></ol><p>因此遍历一个子结构就可以这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// traversal the substructure of tree</span><br><span class="line">// Input: SubStructure of tree</span><br><span class="line"></span><br><span class="line">function traversalSubStructure(Tree subTreeRoot):</span><br><span class="line">    access(subTreeRoot)</span><br><span class="line">    for i in 0 to subTreeRoot.children.length</span><br><span class="line">        traversalSubStructure(subTreeRoot.children[i])</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>由于多叉树所有的子结构共同组成整个多叉树（即可以被递归定义），所以我们可以用递归来完成遍历。<br>如何使用递归？只需要确认好边界条件即可。初始条件当然是放入一个树的根，停止向下递归则是遇到了叶子节点，即这个节点的children域为空。所以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Traversal tree</span><br><span class="line">// Input: root of tree</span><br><span class="line"></span><br><span class="line">function traversalTree(Tree treeRoot):</span><br><span class="line">    if treeRoot not null then</span><br><span class="line">        access(treeRoot)</span><br><span class="line">        for i in 0 to treeRoot.children.length</span><br><span class="line">            traversalSubStructure(treeRoot.children[i])</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>说了那么多，我想表达的是：如果一个节点，它的子节点可以用循环来列举的话，那我们可以用循环+递归的形式来进行遍历这个图。<br>更近一步来说，我们可以用递归+一个for循环来实现n重循环，进而进行遍历。n重循环天生就适合拿来作为枚举的工具。所以，我们可以把问题写成n重循环的形式，然后再转化成递归，就可以用DFS来解决遍历问题。<br>因此，DFS可以写成如下形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void DFS(Graph graph) &#123;</span><br><span class="line">    if(边界条件) &#123;</span><br><span class="line">        for(i;循环条件;i++) &#123;</span><br><span class="line">        DFS(graph.child.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-两个问题"><a href="#4-两个问题" class="headerlink" title="4. 两个问题"></a>4. 两个问题</h2><p>在刷题的过程中，我遇到了两个很有意思的问题，都可以用DFS来解决，这里分享一下，分别是迷宫问题和不重复字符的字符串。</p><h3 id="4-1-迷宫问题"><a href="#4-1-迷宫问题" class="headerlink" title="4.1. 迷宫问题"></a>4.1. 迷宫问题</h3><p>长话短说，迷宫问题是这么被描述的（LeetCode上的描述很长，我就不贴了）：<br>给定一个二维数组来表示一个迷宫。这个数组里的元素要么为0要么为1；0代表可以通过，1代表是墙壁，不可通过。<br>比如说，给定一个二维数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] maze = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>它表示这个迷宫，灰色为墙壁，白色为通路：<br><img src="/18/DFS/2018/10/18/DFS/Maze.jpg" title="迷宫"><br>现在，给定一个起点和终点，找出一条可行的路径来走出这个迷宫。</p><p>不妨以上图为例子，起点为(1, 1)，终点为(6, 5)。</p><p>如何用DFS的实现来解决迷宫问题？我们走到一个点时（必然的，这个点的值为0，即为通路），我们可以选择向上、向下、向左或者是向右走；而前面的问题，都是一个父节点带着n个子节点的情形，我们可以照葫芦画瓢，父节点就是当前节点，而子节点就是上、下、左以及右的节点，画成图的话是这样的：<br><img src="/18/DFS/2018/10/18/DFS/FourStep.jpg" title="子结构"></p><p>先对这个子结构进行遍历，伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Traversal currentPoint and its North, South, West and East Point</span><br><span class="line">// Input: maze, currentPoint</span><br><span class="line"></span><br><span class="line">function traversalCurrentPoint(Maze maze, Point currentPoint):</span><br><span class="line">    for point in &#123;currentPoint.North, currentPoint.South, currentPoint.West, currentPoint.East&#125; :</span><br><span class="line">        traversalCurrentPoint(point)</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>接下来确定好边界条件，初始条件当然是给一个起点，停止向下递归的条件是：</p><ol><li>遇上墙壁</li><li>遇上终点</li></ol><p>所以，对每个子结构遍历的伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Solve Maze Problem</span><br><span class="line">// Input: maze, start, end</span><br><span class="line"></span><br><span class="line">function solveMaze(Maze maze, Point start, Point end, Result result):</span><br><span class="line">    if start == end then </span><br><span class="line">        result.add(start)</span><br><span class="line">        return</span><br><span class="line">    else if is not wall then </span><br><span class="line">        result.add(start)</span><br><span class="line">        for Point in &#123;start.North, start.South, start.West, start.East&#125; :</span><br><span class="line">            solveMaze(maze, start, end, result)</span><br><span class="line">        result.remove(start)</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>因此，相应的Java代码实现有：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Point[] getPoints(Point currentPoint) &#123;</span><br><span class="line">    <span class="keyword">int</span> currentX = currentPoint.x;</span><br><span class="line">    <span class="keyword">int</span> currentY = currentPoint.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Point[]&#123;</span><br><span class="line">            <span class="keyword">new</span> Point(currentX - <span class="number">1</span>, currentY), <span class="comment">// North</span></span><br><span class="line">            <span class="keyword">new</span> Point(currentX + <span class="number">1</span>, currentY), <span class="comment">// South</span></span><br><span class="line">            <span class="keyword">new</span> Point(currentX, currentY - <span class="number">1</span>), <span class="comment">// West</span></span><br><span class="line">            <span class="keyword">new</span> Point(currentX, currentY + <span class="number">1</span>)  <span class="comment">// East</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">solveMaze</span><span class="params">(<span class="keyword">int</span>[][] maze, List&lt;Point&gt; result, Point start, Point end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = start.x;</span><br><span class="line">    <span class="keyword">int</span> y = start.y;</span><br><span class="line">    <span class="keyword">if</span> (x == end.x &amp;&amp; y == end.y) &#123;</span><br><span class="line">        result.add(start);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.add(start);</span><br><span class="line">        Point[] points = getPoints(start);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isValidPoint(maze, points[i])</span><br><span class="line">                   &amp;&amp; hasNotAccess(result, points[i])</span><br><span class="line">                   &amp;&amp; solveMaze(maze, result, points[i], end)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.remove(start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中isValidPoint()会判断是否越界或者遇上墙壁；而hasNotAccess()会判断节点是否被访问过，这么做可以防止<code>North -&gt; South -&gt; North ...</code>或者<code>East -&gt; West -&gt; East ...</code>的死循环。</p><p>代码的思路就是把所有子节点转换成可以被for循环枚举，每走一步，以当前节点为父节点继续枚举（即向下遍历），直到遇到终点或者墙壁后回溯。其实，这段DFS代码的可以转换成一个n重循环。</p><h3 id="4-2-不重复的字符的字符串"><a href="#4-2-不重复的字符的字符串" class="headerlink" title="4.2. 不重复的字符的字符串"></a>4.2. 不重复的字符的字符串</h3><p>其实这题不是LeetCode上的，是我从同学那里听说的。听完题目之后觉得挺有意思的，觉得用DFS可解，然后码了下代码，发现真的可以。<br>这道题是这么描述的：</p><p>给定一个没有重复字符的字符串s，字符串的第i个字符用s<sub>i</sub>表示，即s = s<sub>1</sub>s<sub>2</sub>s<sub>3</sub>…s<sub>i</sub>…s<sub>n</sub><br>请给出k个不重复的，由s[1…n]组成的，没有重复字符，长度为n的字符串。<br>Example 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;Input:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = “01234567”, k = 3<br>&nbsp;&nbsp;&nbsp;&nbsp;Output:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”01234567”, “74625310”, “45367201”</p><p>Example 2:<br>&nbsp;&nbsp;&nbsp;&nbsp;Input:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s =”abc”, k = 5<br>&nbsp;&nbsp;&nbsp;&nbsp;Output:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”abc”, “bca”, “cba”, “acb”, “bac”</p><p>给定的字符串s是一维的，明显不能直接用DFS来搜索。能使用DFS，数据必须是二维的。于是我们可以构造一个矩阵，矩阵就是二维的，以s = “abcd”为例，如下：<br><img src="/18/DFS/2018/10/18/DFS/Matrix.jpg" title="构造矩阵"></p><p>为什么我会想到构造一个矩阵出来？原因不难理解。前面我不断的说：<code>DFS代码可以转换成一个n重循环</code>。n重循环很好枚举，所以我就构造出一个4*4的矩阵，每一行都是s<br>这样我就能写成如下形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for i in 0 ~ 3:</span><br><span class="line">    for j in 0 ~ 3: </span><br><span class="line">        for m in 0 ~ 3: </span><br><span class="line">            for n in 0 ~ 3: </span><br><span class="line">                rs = s[i] + s[j] + s[m] + s[n]</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>然后我就可以转成递归的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in 0 ~ 3: </span><br><span class="line">    DFS(s, i)</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>于是，相应的实现代码就好写了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bruteSearch</span><span class="params">(String[] targetStringMatrix, StringBuilder stringBuilder, List&lt;String&gt; result, <span class="keyword">int</span>[] accessFlag, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth &lt; targetStringMatrix.length) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; targetStringMatrix[depth].length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (accessFlag[i] != <span class="number">1</span>) &#123;</span><br><span class="line">                stringBuilder.append(targetStringMatrix[depth].charAt(i));</span><br><span class="line">                accessFlag[i] = <span class="number">1</span>;</span><br><span class="line">                bruteSearch(targetStringMatrix, stringBuilder, result, accessFlag, depth + <span class="number">1</span>);</span><br><span class="line">                accessFlag[i] = <span class="number">0</span>;</span><br><span class="line">                stringBuilder.deleteCharAt(stringBuilder.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.add(stringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先解释一下参数列表：<br>其中targetStringMatrix是根据s构造出来的矩阵；<br>stringBuilder是用来拼接字符的对象；<br>result是用来存放结果的对象；<br>accessFlag是存放访问结果，如果第i个元素为0则表示第i个字符还没被访问（拼接），否则如果为1则表明已经被访问（拼接）过；<br>depth表示已经拼接字符的个数。</p><p>然后就是方法体：<br>首先判断是否超过最大深度，即<code>depth</code>是否等于4。<br>如果小于4：那就遍历<code>targetStringMatrix[depth][0...3]</code>。如果<code>targetStringMatrix[depth][i]</code>没被访问过，那就把<code>accessFlag[i]</code>置1，然后用<code>stringBuilder</code>把<code>targetStringMatrix[depth][i]</code>拼接进来，然后向下遍历，直至回溯回来后，将访问标志<code>accessFlag[i]</code>置0，把<code>targetStringMatrix[depth][i]</code>从<code>stringBuilder</code>中移除。</p><p>否则，如果<code>depth</code>等于4：说明此时<code>stringBuilder.length() == 4</code>，那就把它加到结果<code>result</code>里就ok了。其实还是一个n重循环问题。</p><h2 id="5-由两个问题所引发的思考"><a href="#5-由两个问题所引发的思考" class="headerlink" title="5. 由两个问题所引发的思考"></a>5. 由两个问题所引发的思考</h2><p>上面已经解释了，DFS可以写成n重循环的形式。所以DFS和n重循环有什么关系？<br>DFS的基本形式，就是一个循环内调用自身。即一个循环+递归的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function DFS(graph, depth):</span><br><span class="line">    if depth &lt; maxDepth then</span><br><span class="line">        for i in 0 ~ graph.get(depth).length():</span><br><span class="line">            access(graph, depth)</span><br><span class="line">            DFS(graph, depth + 1)</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>如果<code>graph</code>是4*4的，如果调用<code>DFS(graph, 0)</code>，<br>那么第一层：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in 0 ~ 3:</span><br><span class="line">    if 0 &lt; 4 then</span><br><span class="line">        access(graph, 0)</span><br><span class="line">        DFS(graph, 0 + 1)</span><br><span class="line">        end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>第二层：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in 0 ~ 3:</span><br><span class="line">    if 1 &lt; 4 then</span><br><span class="line">        access(graph, 1)</span><br><span class="line">        DFS(graph, 1 + 1)</span><br><span class="line">        end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>第三层：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in 0 ~ 3:</span><br><span class="line">    if 2 &lt; 4 then</span><br><span class="line">        access(graph, 2)</span><br><span class="line">        DFS(graph, 2 + 1)</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>第四层：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in 0 ~ 3:</span><br><span class="line">    if 3 &lt; 4 then</span><br><span class="line">        access(graph, 3)</span><br><span class="line">        DFS(graph, 3 + 1)</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>把第i层的<code>DFS(graph, (i - 1) + 1)</code>替换成第i + 1层的代码，可以得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">for i in 0 ~ 3:</span><br><span class="line">    if 0 &lt; 4 then</span><br><span class="line">        access(graph, 0)</span><br><span class="line">        for i in 0 ~ 3:</span><br><span class="line">            if 1 &lt; 4 then</span><br><span class="line">                access(graph, 1)</span><br><span class="line">                for i in 0 ~ 3:</span><br><span class="line">                    if 2 &lt; 4 then</span><br><span class="line">                        access(graph, 2)</span><br><span class="line">                        for i in 0 ~ 3:</span><br><span class="line">                            if 3 &lt; 4 then</span><br><span class="line">                                access(graph, 3)</span><br><span class="line">                                DFS(graph, 3 + 1)</span><br><span class="line">                            end</span><br><span class="line">                        end</span><br><span class="line">                    end</span><br><span class="line">                end</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>从上面可以看出，DFS本质就是一个n重循环，DFS自然可以用n重循环来表示。</p><p>其实，观察每一层，每一层不一样的地方也就只有传的参数的值不同，也能看出这就是一个n重循环，有点像数学归纳法的递推。<br>还有就是，我上面不断的提<code>子结构</code>，其实我个人觉得能写成递归解决的问题，都很像数学中的分形。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>如果一个枚举问题，它的子结构共同组成该问题，就像上面提到的迷宫问题一样，每走一步后，可以上下左右走，这是一个子结构，共同组成原问题，那么这个问题就可以写成n重循环的形式。既然能够写成n重循环的形式，自然就能转化成递归的形式，就能用DFS的思想解决。<br>如果一个枚举问题，它的子结构不能组成该问题，那我们就可以转化一下，如果能转化成让它可以由子结构组成，就像上面提到的不重复字符的字符串一样，一维的字符串自然没有子结构能够组成这个问题，那我们就构造一个矩阵，这样我们就能在递归深度为depth时，访问第1，第2 … 第n个元素，写成n重循环的形式，从而转化成递归进而用DFS的实现解决。<br>DFS是解决枚举问题的基础，但不是所有问题都能照搬DFS的代码得到解决，我们需要稍微修改一下才可，比如不重复字符的字符串问题。</p><h2 id="7-感想"><a href="#7-感想" class="headerlink" title="7. 感想"></a>7. 感想</h2><p>在这之前，我对DFS的理解，也仅仅只是对二叉树的遍历。刷了一定量的题，我慢慢发现，只要给初始条件和停止条件，递归可以解决需要多重循环的问题，也就是DFS的实现。所以刷题还是有用的！想要对算法有理解还是要多刷题(不会可以看看Discussion，里面各路大神各种骚操作，都能解决问题)。就这样吧。如果本文有什么问题，请指教，共同进步，谢谢~！</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/18/DFS/2018/10/18/DFS/cover.jpeg&quot;&gt;
&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;上周刷了20来道LeetCode的题，总结出了一些关于深度优先搜索的小小的心得，于是有了这篇博客。这次的总体思路是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;深度优先搜索算法的工作过程&lt;/li&gt;
&lt;li&gt;如何使用深度优先搜索算法来进行遍历&lt;/li&gt;
&lt;li&gt;两个有趣的问题&lt;/li&gt;
&lt;li&gt;深度优先搜索算法和循环的关系&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="www.zspirytus.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>可拖拽的FloatingActionButton</title>
    <link href="www.zspirytus.com/2018/08/22/DraggableFloatingActionButton/"/>
    <id>www.zspirytus.com/2018/08/22/DraggableFloatingActionButton/</id>
    <published>2018-08-22T10:52:48.000Z</published>
    <updated>2018-10-02T18:17:39.428Z</updated>
    
    <content type="html"><![CDATA[<img src="/22/DraggableFloatingActionButton/2018/08/22/DraggableFloatingActionButton/draggablefloatingactionbutton_cover.jpg" title="cover"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>FloatingActionButton是Google力推的一个Material Design控件。最近做的一个项目，需要实现一个可以左右滑动，松手回到原位的FloatingActionButton。研究了大半天就写出来了，于是写写这片博客记录一下。</p><a id="more"></a><h2 id="MotionEvent的事件"><a href="#MotionEvent的事件" class="headerlink" title="MotionEvent的事件"></a>MotionEvent的事件</h2><p>当我们点击一个view，或者拖动一个view到处滑动时，都会产生一个MotionEvent事件。</p><ul><li>当我们的手指刚刚点击到屏幕时，会产生MotionEvent.ACTION_DOWN事件；</li><li>当我们的手指在屏幕上到处滑动时，会产生MotionEvent.ACTION_MOVE事件；</li><li>当我们的手指离开屏幕时，会产生MotionEvent.ACTION_UP事件。</li></ul><p>那么这就好办了，当产生了MotionEvent.ACTION_MOVE事件时，只需要获得屏幕触点的坐标，把fab移动过去就行了</p><h2 id="设置OnTouchListener"><a href="#设置OnTouchListener" class="headerlink" title="设置OnTouchListener"></a>设置OnTouchListener</h2><p>前面已经说明了，view会产生MotionEvent.ACTION_DOWN，MotionEvent.ACTION_MOVE 和 MotionEvent.ACTION_UP事件。问题是如何捕获这些事件。当我们的手指开始接触屏幕，直到离开屏幕前，View.onTouch()方法都会被调用，而且这个方法的参数中有MotionEvent参数，可以获取事件。因此我们需要实现该方法，并为fab设置OnTouchListener监听器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mFab.setOnTouchListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View view, MotionEvent motionEvent)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就可以通过motionEvent来获得事件，并根据事件来响应。实现的思路已经很明显了，接下来分事件来说明。</p><h3 id="MotionEvent-ACTION-DOWN"><a href="#MotionEvent-ACTION-DOWN" class="headerlink" title="MotionEvent.ACTION_DOWN"></a>MotionEvent.ACTION_DOWN</h3><p>当手指开始接触屏幕时，会产生MotionEvent.ACTION_DOWN事件。<br>这时要做一件事，记录下『mFab初始坐标X值和触点坐标X值之差』，以供备用。<br>其中initRawX为mFab的初始坐标的X值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">    dX = initRawX - motionEvent.getRawX();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><h3 id="MotionEvent-ACTION-MOVE"><a href="#MotionEvent-ACTION-MOVE" class="headerlink" title="MotionEvent.ACTION_MOVE"></a>MotionEvent.ACTION_MOVE</h3><p>当手指开始在屏幕上滑动时，会产生MotionEvent.ACTION_MOVE事件。<br>这时需要实现mFab跟随手指移动的功能。<br>要实现mFab移动的功能，我们必须计算出手指移动的距离deltaX，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deltaX = (motionEvent.getRawX() - initRawX + dX) * damping;</span><br></pre></td></tr></table></figure><p>其中damping是阻尼，0 &lt; damping &lt;= 1.</p><p>计算出手指移动的距离deltaX后：</p><ul><li>当移动的距离deltaX满足 -CLICK_DRAG_TOLERANCE &lt; deltaX &lt; CLICK_DRAG_TOLERANCE时，mFab不用移动，因为我们单击mFab时，是不需要mFab移动的。</li><li>当移动的距离deltaX满足 deltaX &gt; border 或 deltaX &lt; -border 时，mFab则停留在border或-border的位置就可以了。</li></ul><p>所以便有：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (deltaX &lt; -border) &#123;</span><br><span class="line">    deltaX = -border;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaX &lt; -CLICK_DRAG_TOLERANCE) &#123;</span><br><span class="line">    setImageResource(R.drawable.ic_skip_previous_white_48dp);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaX &gt; CLICK_DRAG_TOLERANCE &amp;&amp; deltaX &lt;= border) &#123;</span><br><span class="line">    setImageResource(R.drawable.ic_skip_next_white_48dp);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaX &gt; border) &#123;</span><br><span class="line">    deltaX = border;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Math.abs(deltaX) &gt;= CLICK_DRAG_TOLERANCE) &#123;</span><br><span class="line">    <span class="comment">// 此时deltaX已经大于mFab移动的阈值CLICK_DRAG_TOLERANCE，mFab移动deltaX个单位。</span></span><br><span class="line">    view.animate()</span><br><span class="line">        .x(initRawX + deltaX)</span><br><span class="line">        .setDuration(RESPONSE_ACTION_MOVE_DELAY)</span><br><span class="line">        <span class="comment">// RESPONSE_ACTION_MOVE_DELAY == 0，立即移动</span></span><br><span class="line">        .start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><br>其中CLICK_DRAG_TOLERANCE是mFab能移动距离的阈值。</p><h3 id="MotionEvent-ACTION-UP"><a href="#MotionEvent-ACTION-UP" class="headerlink" title="MotionEvent.ACTION_UP"></a>MotionEvent.ACTION_UP</h3><p>当手指离开屏幕时，会产生MotionEvent.ACTION_UP事件。<br>这个时候就可以处理单击、左滑和右滑的事件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (onDraggableFABEventListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(deltaX) &lt; CLICK_DRAG_TOLERANCE) &#123;</span><br><span class="line">        onDraggableFABEventListener.onClick();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (deltaX == border) &#123;</span><br><span class="line">            onDraggableFABEventListener.onDraggedRight();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaX == -border) &#123;</span><br><span class="line">            onDraggableFABEventListener.onDraggedLeft();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果deltaX的绝对值小于CLICK_DRAG_TOLERANCE，则表明是单击事件；<br>否则如果deltaX == border，则表明是右滑事件；<br>否则如果deltaX == -border，则表明是左滑事件。</p><p>处理完事件后，mFab要回到原位，因此：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">view.animate()</span><br><span class="line">        .x(initRawX)</span><br><span class="line">        .setDuration(RESET_ANIMATOR_DURATION)</span><br><span class="line">        <span class="comment">// RESET_ANIMATOR_DURATION &gt; 0</span></span><br><span class="line">        .start();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></p><p>至此，整个onTouch方法就完成了！以下是完整代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View view, MotionEvent motionEvent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> action = motionEvent.getAction();</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            dX = initRawX - motionEvent.getRawX();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            deltaX = (motionEvent.getRawX() - initRawX + dX) * damping;</span><br><span class="line">            <span class="keyword">if</span> (deltaX &lt; -border) &#123;</span><br><span class="line">                deltaX = -border;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaX &lt; -CLICK_DRAG_TOLERANCE) &#123;</span><br><span class="line">                setImageResource(R.drawable.ic_skip_previous_white_48dp);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaX &gt; CLICK_DRAG_TOLERANCE &amp;&amp; deltaX &lt;= border) &#123;</span><br><span class="line">                setImageResource(R.drawable.ic_skip_next_white_48dp);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaX &gt; border) &#123;</span><br><span class="line">                deltaX = border;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(deltaX) &gt;= CLICK_DRAG_TOLERANCE) &#123;</span><br><span class="line">                view.animate()</span><br><span class="line">                        .x(initRawX + deltaX)</span><br><span class="line">                        .setDuration(RESPONSE_ACTION_MOVE_DELAY)</span><br><span class="line">                        .start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="keyword">int</span> resId = MediaPlayController.getInstance().isPlaying() ? R.drawable.ic_pause_white_48dp : R.drawable.ic_play_arrow_white_48dp;</span><br><span class="line">            setImageResource(resId);</span><br><span class="line">            <span class="keyword">if</span> (onDraggableFABEventListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(deltaX) &lt; CLICK_DRAG_TOLERANCE) &#123;</span><br><span class="line">                    onDraggableFABEventListener.onClick();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (deltaX == border) &#123;</span><br><span class="line">                        onDraggableFABEventListener.onDraggedRight();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaX == -border) &#123;</span><br><span class="line">                        onDraggableFABEventListener.onDraggedLeft();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            view.animate()</span><br><span class="line">                    .x(initRawX)</span><br><span class="line">                    .setDuration(RESET_ANIMATOR_DURATION)</span><br><span class="line">                    .start();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(motionEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="mFab的初始位置"><a href="#mFab的初始位置" class="headerlink" title="mFab的初始位置"></a>mFab的初始位置</h2><p>前面的onTouch方法需要initRawX的值，我们如何获得这个值？<br><code>this.getX()</code>是不可行的，因为当执行<code>this.getX()</code>的时候，不能保证mFab已经被绘制出来了；而如果mFab没有绘制出来，<code>this.getX()</code>将会返回0。因此我们需要在适当的实际调用<code>this.getX()</code>来获取initRawX。<br>onWindowFocusChanged()方法是在Activity的onResume()后被调用，当Activity的onResume()方法被调用后，Activity是可见，可与用户交互的，说明view都已经绘制完毕，所以我们可以在onWindowFocusChanged()方法中获取mFab的初始坐标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasWindowFocus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onWindowFocusChanged(hasWindowFocus);</span><br><span class="line">    <span class="comment">// get mFab initial location X</span></span><br><span class="line">    initRawX = getX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实可拖拽的FloatingActionButton的实现原理很简单，只需要为mFab设置OnTouchListener，在监听器中捕获MotionEvent.ACTION_DOWN、MotionEvent.ACTION_MOVE、MotionEvent.ACTION_UP 事件，再分别处理事件即可。完整代码可以看<a href="https://github.com/zkw012300/DraggableFloatingActionButton/blob/master/mylibrary/src/main/java/com/zspirytus/mylibrary/DraggableFloatingActionButton.java" target="_blank" rel="noopener">这里</a>。</p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>之前看Android中的View事件的分发机制，第一次接触到了ACTION_DOWN、ACTION_MOVE、ACTION_UP事件，看了一遍云里雾里的，但是多看几遍后就开始理解。这次的可拖拽的FloatingActionButton是我在写的项目中的一个小控件，有了之前的基础，写起来不太吃力。所以我认为这三个事件还是蛮重要的。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/22/DraggableFloatingActionButton/2018/08/22/DraggableFloatingActionButton/draggablefloatingactionbutton_cover.jpg&quot; title=&quot;cover&quot;&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;FloatingActionButton是Google力推的一个Material Design控件。最近做的一个项目，需要实现一个可以左右滑动，松手回到原位的FloatingActionButton。研究了大半天就写出来了，于是写写这片博客记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="www.zspirytus.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>设计模式——观察者模式</title>
    <link href="www.zspirytus.com/2018/07/26/Observer/"/>
    <id>www.zspirytus.com/2018/07/26/Observer/</id>
    <published>2018-07-26T15:54:55.000Z</published>
    <updated>2018-10-02T18:20:32.323Z</updated>
    
    <content type="html"><![CDATA[<img src="/26/Observer/2018/07/26/Observer/observer_cover.jpeg" title="cover"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>嗯，观察者模式在Android开发中还是挺常用的，比如说Adapter数据更新后RecyclerView的刷新，以及四大组件的Broadcast等等。接下来本文将简单谈谈设计模式中的观察和模式。<br>为了有更好的食用体验，本文会结合一个简单的例子，让你更好的理解观察者模式。<br><a id="more"></a></p><h2 id="一、观察者模式"><a href="#一、观察者模式" class="headerlink" title="一、观察者模式"></a>一、观察者模式</h2><p>先来看看定义：定义对象之间的一对多依赖关系，当一个对象改变状态时，它的所有依赖对象都会自动获得通知。<br>emmm…一对多依赖关系？？？状态改变依赖对象会被通知？？？定义有点拗口，不如直接看看一个例子。<br>小时候各位都有做过眼保健操吧，当广播响起眼保健操的音乐时，我们就开始做眼保健操。此时，广播和学生构成了一对多的依赖：当广播播放眼保健操的音乐时，即广播的状态发生改变时，我们获得要开始做眼保健操的通知。</p><h2 id="二、观察者模式中的角色"><a href="#二、观察者模式中的角色" class="headerlink" title="二、观察者模式中的角色"></a>二、观察者模式中的角色</h2><p>观察者模式，就像它的名字一样，这个设计模式中有一个角色叫『观察者』，同样的也有一个角色叫『被观察者』。它们都是抽象出来的概念，因此它们的具体的实现是『具体观察者』和『具体被观察者』。<br>在上面的例子中，『广播』扮演的的是『被观察者』的角色；『发送眼保健操音乐的广播』扮演的是『具体被观察者』的角色；『学生』扮演的是『具体观察者』的角色；而『观察者』的角色并不明显，它扮演的是接口的角色。如下例子：<br>定义观察者：<br><figure class="highlight java"><figcaption><span>Observer.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(BroadCast broadCast)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义具体观察者——Student<br><figure class="highlight java"><figcaption><span>Student.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = Student.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(BroadCast broadCast)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"send Eye Exercises BroadCast! "</span>.equals(broadCast.getBroadCast())) &#123;</span><br><span class="line">            System.out.println(TAG + <span class="string">": I will do eye exercises!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(TAG + <span class="string">":I will be back home!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义被观察者——BroadCast：<br><figure class="highlight java"><figcaption><span>BroadCast.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadCast</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!observers.contains(observer)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (BroadCast.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!observers.contains(observer)) &#123;</span><br><span class="line">                    observers.add(observer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unRegister</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!observers.contains(observer)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (BroadCast.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!observers.contains(observer)) &#123;</span><br><span class="line">                    observers.remove(observer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notifyAllObserver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Iterator&lt;Observer&gt; iterator = observers.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Observer observer = iterator.next();</span><br><span class="line">            observer.doSomething(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getBroadCast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sendBroadCast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义具体的被观察者——眼保健操广播和放学铃声广播：<br><figure class="highlight java"><figcaption><span>EyeExercisesBroadCast.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EyeExercisesBroadCast</span> <span class="keyword">extends</span> <span class="title">BroadCast</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EyeExercisesBroadCast INSTANCE = <span class="keyword">new</span> EyeExercisesBroadCast();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String broadCastMessage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EyeExercisesBroadCast</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EyeExercisesBroadCast <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBroadCast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> broadCastMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadCast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        broadCastMessage = <span class="string">"send Eye Exercises BroadCast! "</span>;</span><br><span class="line">        notifyAllObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><figcaption><span>FinishClassBroadCast.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinishClassBroadCast</span> <span class="keyword">extends</span> <span class="title">BroadCast</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FinishClassBroadCast INSTANCE = <span class="keyword">new</span> FinishClassBroadCast();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String broadCastMessage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FinishClassBroadCast</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FinishClassBroadCast <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBroadCast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> broadCastMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadCast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        broadCastMessage = <span class="string">"send finish class BroadCast! "</span>;</span><br><span class="line">        notifyAllObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外在定义两个辅助类Main和Teacher，Main负责执行代码，而Teacher是广播的管理者，可以管理广播的发送<br><figure class="highlight java"><figcaption><span>Main.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        BroadCast broadCast1 = EyeExercisesBroadCast.getInstance();</span><br><span class="line">        BroadCast broadCast2 = FinishClassBroadCast.getInstance();</span><br><span class="line">        broadCast1.register(student);</span><br><span class="line">        broadCast2.register(student);</span><br><span class="line">        Teacher teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><figcaption><span>Teacher.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = Teacher.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BroadCast[] broadCasts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        System.out.println(TAG+<span class="string">": I send eye exercises broadcast! "</span>);</span><br><span class="line">        sendEyeExercisesBroadCast();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep((<span class="keyword">int</span>) (Math.random() * <span class="number">6</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(TAG+<span class="string">": I send finish class broadcast! "</span>);</span><br><span class="line">        sendFinishClassBroadCast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        broadCasts = <span class="keyword">new</span> BroadCast[<span class="number">2</span>];</span><br><span class="line">        broadCasts[<span class="number">0</span>] = EyeExercisesBroadCast.getInstance();</span><br><span class="line">        broadCasts[<span class="number">1</span>] = FinishClassBroadCast.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendEyeExercisesBroadCast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        broadCasts[<span class="number">0</span>].sendBroadCast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendFinishClassBroadCast</span><span class="params">()</span></span>&#123;</span><br><span class="line">        broadCasts[<span class="number">1</span>].sendBroadCast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时运行程序，当广播播放眼保健操的音乐时，学生便收到通知，开始做眼保健操；当广播播放放学铃声时，学生便收到通知，开始离校。运行结果如下：<br><img src="/26/Observer/2018/07/26/Observer/result.png" title="运行结果"></p><h2 id="三、观察者模式的工作原理"><a href="#三、观察者模式的工作原理" class="headerlink" title="三、观察者模式的工作原理"></a>三、观察者模式的工作原理</h2><p>在观察者模式中，Observer观察Observable。这个过程有几个关键点：</p><ul><li>与大部分现实不同的是，Observer不是主动观察，而是被动的接收来自Observable的通知</li><li>Observable要知道谁在观察它，才能在状态改变的时候通知，因此它需要维护一个List&lt;Observer></li><li>Observer中要有一个传入Observable参数的回调方法，以便Observer在收到通知时能够获得Observable的状态</li></ul><p>首先，Observer是被动的接收来自Observable的通知，因为我们引入观察者模式的目的之一就是为了避免轮询消耗CPU资源，所以比较合适的方法应该是当Observable状态发生改变时再去通知Observer。就像上面的例子，脑补一下画面：学生不必不停的问老师：放学了吗？放学了吗？放学了吗？…老师回答：没有。没有。没有。…放学了。这样很喜感，也太消耗体力(CPU资源)。</p><p>其次，正是因为Observable需要通知Observer，所以Observable需要知道谁是Observer，即需要存储所有Observer对象，因此它需要维护一个List&lt;Observer>，至于List&lt;Observer>的数据结构如何选用，就要看看实际情况了。就像上面的例子：因为广播(即Observable)知道它要通知的是学生，所以才会被安装在教室和走廊里(不然装在闹市区突然响起眼保健操的音乐，路人一脸黑人问号)。</p><p>最后，Observer需要知道Observable的通知内容，因此Observable要在回调函数(的参数)中放入通知内容，Observer可以在回调函数中(的参数)获得通知内容。在上面的例子中，学生是可以通过广播获得放学的信息的。</p><p>另外，如果存在优先级的问题，可以List&lt;Observer>把按优先级排序以下，再进行通知。如果在通知的时候(for循环里面)加一点逻辑，可以实现类似于Android系统中有序广播的功能。</p><h2 id="四、回调函数的参数列表"><a href="#四、回调函数的参数列表" class="headerlink" title="四、回调函数的参数列表"></a>四、回调函数的参数列表</h2><p>在第三部分提到，Observer可以通过回调函数获取通知内容。但是这个通知内容是什么？是直接传一个Observable参数好，还是直接传message参数的参数好？还是两个一起传？不如分别讨论。</p><h3 id="4-1-只传Observable参数"><a href="#4-1-只传Observable参数" class="headerlink" title="4.1.只传Observable参数"></a>4.1.只传Observable参数</h3><p>只传Observable参数，简单，不会有一大堆重载函数。但是可能会有意想不到的安全问题：Student类实现了Observer接口，可以通过doSomething(BroadCast)获取BroadCast对象，然而BroadCast的notifyAllObserver方法是public的！即使我们相信学生不会为了恶作剧而重复发广播，但是这个问题还是有可能发生的。从编程的角度，在代码运行时，如果观察者接收到信息后调用BroadCast.notifyAllObserver()方法后，是会爆栈的。比如说，修改Student.doSomething(BroadCast)方法：<br><figure class="highlight java"><figcaption><span>Student.doSomething(BroadCast)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(BroadCast broadCast)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"send Eye Exercises BroadCast! "</span>.equals(broadCast.getBroadCast()))&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName()+<span class="string">": I will do eye exercises!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName()+<span class="string">":I will be back home!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    broadCast.notifyAllObserver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里增加了一行broadCast.notifyAllObserver()，再重新执行main方法，结果如下：</p><img src="/26/Observer/2018/07/26/Observer/StackBomb.png" title="StackBomb"><p>很不幸爆栈了。因此我们要把notifyAllObserver方法屏蔽掉，只有BroadCast及其它的子类能碰。因此notifyAllObserver方法需要被protected关键词修饰，并且其BroadCast的子类需要和BroadCast同包。修改后包结构如下：</p><img src="/26/Observer/2018/07/26/Observer/PackageStructure.png" title="Package Structure"><p>通过修改notifyAllObserver()的访问权限，就能解决安全问题。</p><h3 id="4-2-只传message参数"><a href="#4-2-只传message参数" class="headerlink" title="4.2.只传message参数"></a>4.2.只传message参数</h3><p>只传message参数？似乎看起来并没有什么问题。但是message可能不止一个！而且Observable不知道Observer需要什么样的message。假设多个Observer要观察Observable中的n个message中任意多个，它们需要的message可能各不相同。所以回调函数就必须要有2<sup>n</sup>个，这样才可以满足所有Observer的需求。显然这样是不可取的，因为重载函数的增加降低了程序的可维护性。同时，当Observer观察多个Observable时，当某一个Observable通知它时，Observer无法得知是哪个Observable更新了，所以只传message参数是有一定局限的。</p><h3 id="4-3-同时传Observable和message"><a href="#4-3-同时传Observable和message" class="headerlink" title="4.3.同时传Observable和message"></a>4.3.同时传Observable和message</h3><p>4.2中已经说明，当message有多个时，需要对应指数级个的回调函数，所以在这种多个message的情况下，还是尽量不要传message参数为好。</p><p>所以，个人认为回调函数因只需要传入一个Observable参数。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>一个类可以实现Observer接口来获得『观察』的功能；一个类可以实现Observable接口/抽象类来获得『可观察』的属性。当观察者需要观察被观察者时，它需要实例化出一个被观察者对象，然后调用被观察者的注册方法来注册自己，以便被观察者状态改变时，能够通知自己。<br>个人认为，观察者模式本质是维护一个回调函数集合，在被观察者发生改变时，被观察者便逐个调用这些回调函数，这时观察者就被通知了。<br>另外，基于观察者模式的特性，个人认为观察者模式特别适用于一些异步操作，比如IO操作和网络请求(下载图片并显示在ImageView上等)。</p><h2 id="六、感想"><a href="#六、感想" class="headerlink" title="六、感想"></a>六、感想</h2><p>事实上观察者模式不是我第一个接触的设计模式，我第一个接触的设计模式是『构建者模式』，当时是在学Android开发中的自定义View，没有资料来源所以只能硬啃别人的自定义View的代码，在里面View有必选属性和可选属性，多个构造方法重载和JavaBean模式都不理想，因此构建者模式才被设计出来，结合了这个场景，我也就理解了构建者模式的设计初衷和原理。回到观察者模式，在学Android开发的时候，使用到了RecyclerView，当时不理解为什么它的数据更新的机制，后来看了这本书<a href="https://book.douban.com/subject/26744163/" target="_blank" rel="noopener">《Android开发进阶从小工到专家》</a>，原来RecyclerView的数据更新是适配器模式+观察者模式！结合这本书里面的部分源码，我才理解了RecyclerView的数据更新机制，也就顺手理解了观察者模式的设计初衷。<br>所以设计模式，还是要结合实际场景来学，才能更容易理解然后运用。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/26/Observer/2018/07/26/Observer/observer_cover.jpeg&quot; title=&quot;cover&quot;&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;嗯，观察者模式在Android开发中还是挺常用的，比如说Adapter数据更新后RecyclerView的刷新，以及四大组件的Broadcast等等。接下来本文将简单谈谈设计模式中的观察和模式。&lt;br&gt;为了有更好的食用体验，本文会结合一个简单的例子，让你更好的理解观察者模式。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="www.zspirytus.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>快速排序不快了？重复元素下的快速排序</title>
    <link href="www.zspirytus.com/2018/07/24/quicksort/"/>
    <id>www.zspirytus.com/2018/07/24/quicksort/</id>
    <published>2018-07-24T10:21:14.000Z</published>
    <updated>2018-10-02T18:23:40.174Z</updated>
    
    <content type="html"><![CDATA[<img src="/24/quicksort/2018/07/24/quicksort/quicksort_cover.jpeg" title="cover"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>快速排序，就像它的名字一样，它做排序很快，空间复杂度O(1)下，它的平均时间复杂度为O(nlog<sub>2</sub>n)。但是在某些情况下，快速排序不快了，表现出来的性能和冒泡排序排序这类时间复杂度为O(n<sup>2</sup>)相差无几。因此，本文将解决：</p><ul><li>快速排序的工作原理</li><li>重复元素下的快排</li><li>基本有序下数组下的快排</li></ul><a id="more"></a><h2 id="一、快速排序是如何工作的？"><a href="#一、快速排序是如何工作的？" class="headerlink" title="一、快速排序是如何工作的？"></a>一、快速排序是如何工作的？</h2><p>个人理解，快速排序的工作原理：每轮任意选定一个支点pivot然后确认其最终的位置，然后对支点两边的进行相同的操作，逐渐靠近直至到达有序状态的过程。因此快速排序是分区+递归，分而治之的。</p><h3 id="1-1-分区"><a href="#1-1-分区" class="headerlink" title="1.1.分区"></a>1.1.分区</h3><p>可以看出，快速排序的核心在于：分区。即确定选定支点pivot的最终位置。支点的最终位置在哪里？如果支点的最终位置为x，对于数组arr必然满足</p><p><div style="text-align: center;">arr[0…x-1] ≤ arr[x] ≤ arr[x+1…arr.length-1]</div><br>即：x的左边都比支点小或相等，x的右边都比支点大或相等。<br>所以我们可以使用两个指针i、j。在初始状态下i指向表头，j指向表尾。分区过程中，如果i指向的元素比支点值小，则i++；如果j指向的元素比支点大，则j--，直至i==j。此时i的值即为支点的最终位置。<br>但是，绝大部分待排数据都是无序的，在分区过程中，还存在这种情况：arr[i] &gt; pivotVaule, arr[j] &lt; pivotValue。这种情况会导致内循环不执行，但是外循环条件永真而陷入死循环。因此为了确保分区能顺利进行，遇上这种情况，只需交换i，j指向元素的值。交换完毕后，便回到 arr[i] ≤ pivotVaule, arr[j] ≥ pivotValue。<br>所以分区部分的代码就可以写了（pivot = low为例）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = low;</span><br><span class="line">    <span class="keyword">int</span> pivotValue = arr[pivot];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] ≥ pivotValue)</span><br><span class="line">            high--;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] ≤ pivotValue)</span><br><span class="line">            low++;</span><br><span class="line">        swap(arr,low,high);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr,pivot,low);</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这段代码有几个需要注意的地方：<br>1.pivot的值可以在[low…high]中任意取<br>2.在return前需要交换pivot和low所指向的值。<br>关于第二点，可以确定的是，pivot所指向的地址的对象，从始至终都不会发生改变，因为内循环的条件的第二个子条件都带了等号，说明i和j不会停留在pivot，而是会越过pivot，因此pivot所指向的地址的内容是不会被修改的。既然pivot指向的对象不变，且low为最终支点的位置，所以low和pivot指向的对象互相交换一下就OK了。</p><h3 id="1-2-递归"><a href="#1-2-递归" class="headerlink" title="1.2.递归"></a>1.2.递归</h3><p>递归对应分而治之中的治。为什么经过快速排序后，数组能够变成有序的？不如先看看代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = partition(arr, low, high);</span><br><span class="line">        quickSort(arr, low, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pivot + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>读完代码，可以得到以下信息：<br>1.条件判断是最优先的<br>2.递归过程类似于二叉树的先序遍历</p><p>对于第1点，条件判断先行是为了防止栈溢出或数组越界，没什么好讲的。<br>对于第2点，递归过程很像二叉树的先序遍历，如下图所示：<br><img src="/24/quicksort/2018/07/24/quicksort/quicksort_tree.png" title="普通快速排序递归树"><br>从图中可以看出，如果达到最大递归深度，即low+1=high，图中的叶子节点时会回溯，且每个叶子节点都是有序的，所以所有的叶子节点合起来从左至右是有序的。</p><h3 id="1-3-复杂度"><a href="#1-3-复杂度" class="headerlink" title="1.3.复杂度"></a>1.3.复杂度</h3><p>快排的时间性能如何？从上面可看出快排的过程类似一个二叉树的遍历，最大递归深度直接决定快排的时间性能。假设待排序数组是完全随机的，设时间频度为T(n)，在平均和最佳的情况下，有<br>T(n) = 2T(n/2) + n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;≤ 4T(n/4) + n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;≤ 8T(n/8) + n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;… …<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;≤ log<sub>2</sub>n + nlog<sub>2</sub>n</p><p>因为待排序数组是完全随机的，所以可以认为，i和j指针移动1，2，3…n次的概率为1/n，因此移动距离的期望为n/2，所以一份T(n)可以分成2个T(n/2)加上扫描一次的代价，且扫描一次的代价必然≤n的。所以平均和最佳的情况下，快排的时间复杂度均为O(nlog<sub>2</sub>n)。<br>同时，在最佳的情况下，T(n)同样也是被一分为二的，两份的大小相等，因此和平均的情况一样。</p><p>在最差的情况下，即数组完全有序，快排的时间性能直接退化到O(n<sup>2</sup>)，相当于冒泡排序，递归树退化成链表。</p><h2 id="二、重复元素下的快速排序"><a href="#二、重复元素下的快速排序" class="headerlink" title="二、重复元素下的快速排序"></a>二、重复元素下的快速排序</h2><p>重复元素较多下的快排递归树:<br><img src="/24/quicksort/2018/07/24/quicksort/quicksort_repeat.png" title="重复元素下的快速排序递归树"><br>从图中来看，似乎并没有什么问题，递归树还算比较平衡。但是，数组中共有4个2，4个3，但是普通的快速排序为每个2和每个3都分别确定他们的最终位置，这样的操作显然重复了。如何去掉这些重复操作？可以用三路划分的快速排序。<br>在上图中，数组中共有4个2，4个3，如果能一次确定2或3的最终位置就好了。答案是可以的。在经过一次分区后，我们希望arr[low…high]是这样的<br><img src="/24/quicksort/2018/07/24/quicksort/3way_result.png" title="三路划分"><br>数组的每个元素和pivotValue的大小关系从左到右是&lt;，==和&gt;的，==pivotValue的部分的长度可能不为1。问题是如何达到这个状态。我们可以从五路划分开始，如下图：<br><img src="/24/quicksort/2018/07/24/quicksort/5way_result.png" title="五路划分"><br>为什么可以使用五路划分？或者说，是怎么想到先五路划分的？首先，我们需要明白，在快速排序的分区过程中：</p><ul><li>左右指针没有相遇前，pivotValue的最终位置无法确定</li><li>分区函数的目的是确定pivotValue最终的位置</li></ul><p>在左右指针没有相遇前，最终位置是无法确定的。我们的目标是划分三路，但是能够划分三路的前提是，我们知道了pivotValue的最终位置。在不知道最终位置之前，我们必须找到一个空间来暂时存储和pivotValue的值。最简单的思路是再开辟一个辅助空间。然而快速排序的最大优势是原地排序+nlog<sub>2</sub>n的时间复杂度，如果另外开辟空间，就不再是原地排序，有点舍本取末。因此，还是尽量的不开辟新空间。这是暂时想不出空间复杂度O(1)的缓存方案，不如从第二点入手：分区函数是确认pivotValue最终的位置。就像上面1.1.所说的，这个位置的值是pivotValue。或者说，只要保证最终位置的值是pivotValue就行了，至于其他位置的值是多少可以不用管。因此，其他位置的数据在不损失的条件下是可以操作的，也就是说可以交换。因此，缓存方案就出来了：随机区域的左边，如果遇上和pivotValue相等的值，那就将其放置在表头；随机区域的右边，如果遇上和pivotValue相等的值，就将其放在表尾。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (p &lt; q) &#123;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; q &amp;&amp; arr[q] &gt;= pivotValue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[q] == pivotValue) &#123;</span><br><span class="line">            swap(arr, j, q);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        q--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; q &amp;&amp; arr[p] &lt;= pivotValue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[p] == pivotValue) &#123;</span><br><span class="line">            swap(arr, i, p);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr[p] == pivotValue) &#123;</span><br><span class="line">    p--;</span><br><span class="line">    q++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>需要注意的是退出循环后p == q，arr[p]和pivotValue的大小关系是不能确定的。如果arr[p] == pivotValue，那p--一次，q++一次就OK了。否则不做任何操作，这是为五路化为三路打好基础。<br>因此这份代码结束后，arr可能是两种情况：<br><img src="/24/quicksort/2018/07/24/quicksort/4way_result_1.png" title="五路划分的结果1"><br><img src="/24/quicksort/2018/07/24/quicksort/4way_result_2.png" title="五路划分的结果2"><br>第一张图代表arr[p] != pivotValue 的情况，此时p，q指针不必移动；<br>第二张图代表arr[p] == pivotValue 的情况，此时p，q指针分别需递减和递增一次。</p><p>因为表头表尾都是和pivotValue相等的值，而且pivotValue的最终位置已经确认(p所指向的位置)，所以可以：</p><ul><li>i，p指针所指向的位置交换，同时一起递减，直至i ≥ low</li><li>j，q指针所指向的位置交换，同时一起递增，直至j ≤ high</li></ul><p>所以代码出来了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &gt; low) &#123;</span><br><span class="line">    swap(arr, i - <span class="number">1</span>, p);</span><br><span class="line">    p--;</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j &lt; high) &#123;</span><br><span class="line">    swap(arr, j + <span class="number">1</span>, q);</span><br><span class="line">    q++;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>需要注意一点的是，在交换的时候，i(j)需要减(加)1，这是因为：在发现和pivotValue相等的元素时，是和i(j)的位置交换后，在i++(j--)的，因此i(j)和等于pivotValue的位置是错开一格的，因此i(j)需要减(加)1。</p><p>此时就能从五路转化成三路。此时arr[p…q]都等于pivotValue。<br>完整代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] partition3(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = high;</span><br><span class="line">    <span class="keyword">int</span> p = low;</span><br><span class="line">    <span class="keyword">int</span> q = high;</span><br><span class="line">    <span class="keyword">int</span> pivotValue = arr[low];</span><br><span class="line">    <span class="keyword">while</span> (p &lt; q) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; q &amp;&amp; arr[q] &gt;= pivotValue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[q] == pivotValue) &#123;</span><br><span class="line">                swap(arr, j, q);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            q--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; q &amp;&amp; arr[p] &lt;= pivotValue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[p] == pivotValue) &#123;</span><br><span class="line">                swap(arr, i, p);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[p] == pivotValue) &#123;</span><br><span class="line">        p--;</span><br><span class="line">        q++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; low) &#123;</span><br><span class="line">        swap(arr, i - <span class="number">1</span>, p);</span><br><span class="line">        p--;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; high) &#123;</span><br><span class="line">        swap(arr, j + <span class="number">1</span>, q);</span><br><span class="line">        q++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;p + <span class="number">1</span>, q - <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还是要啰嗦一下，因为边界条件非常重要：最后返回的时候返回的是「new int[]{p + 1, q - 1}」，p(q)是加(减)1后返回的。因为在最后五路归三路的时候，是先交换在p--(q++)的。因此会错开一位，道理跟上面的i(j)是一样的。</p><h2 id="三、基本有序下数组下的快排"><a href="#三、基本有序下数组下的快排" class="headerlink" title="三、基本有序下数组下的快排"></a>三、基本有序下数组下的快排</h2><p>还是从快排的核心——分区函数入手。在完全有序的情况下，时间频度T(n)为：<br>T(n) = T(n -1) + T(1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= T(n -2) + 2 * T(1) + n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= T(n -3) + 3 * T(1) + n + (n - 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;… …<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= T(1) + (n - 1) * T(1) + n + (n - 1) + … + 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= n * T(1) + n + (n - 1) + … + 2 + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= n * T(1) + n<sup>2</sup>/2 + n/2<br>因此，在基本有序的情况下，时间频度T(n)是接近于n * T(1) + n<sup>2</sup>/2 + n/2(T(1)为常数)的。此时递归树极度不平衡。<br>因此在基本有序的数组下，快速排序的性能是十分差的。因此，在数据基本有序的情况下，使用插入排序更好。<br>顺便提一下，插入排序的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i - <span class="number">1</span>] &gt; arr[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = arr[i];</span><br><span class="line">            arr[i] = arr[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; t &lt; arr[j]; j--) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + <span class="number">1</span>] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当数据基本有序时，可以近似认为，插入排序只是把待排数据扫描一遍而已。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>快速排序是一个时间复杂度为O(nlog<sub>2</sub>n)的原地排序。它是的基本原理是确认每轮任意选定一个支点pivot的最终的位置，然后对支点两边的进行相同的操作，逐渐靠近直至到达有序状态。数组应当随机顺序，这样才能保证快速排序的最佳性能，否则可以考虑使用插入排序。倘若遇到重复率较高的随机顺序数组，可以考虑使用三路划分的快速排序来提升排序速度。</p><h2 id="五、感想"><a href="#五、感想" class="headerlink" title="五、感想"></a>五、感想</h2><p>因为之前有简单了研究过，所以这篇文章写的很快，一天就出来了。之前研究的时候，发现快速排序简洁代码的背后蕴含着很多信息，教材给出的代码也只适用于pivot=low的情况，后来我改进了一下，pivot可以任意选，然后就顺手实验一下不同的pivot对快速排序的时间性能影响。通过研究快速排序的机会，我知道了对于排序算法，边界条件很重要，否则很有可能造成数组越界，在递归的情况下也可能造成栈溢出。还有就是任何算法都要在草稿纸上写写画画，这样才能更容易理解其中的原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/24/quicksort/2018/07/24/quicksort/quicksort_cover.jpeg&quot; title=&quot;cover&quot;&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;快速排序，就像它的名字一样，它做排序很快，空间复杂度O(1)下，它的平均时间复杂度为O(nlog&lt;sub&gt;2&lt;/sub&gt;n)。但是在某些情况下，快速排序不快了，表现出来的性能和冒泡排序排序这类时间复杂度为O(n&lt;sup&gt;2&lt;/sup&gt;)相差无几。因此，本文将解决：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速排序的工作原理&lt;/li&gt;
&lt;li&gt;重复元素下的快排&lt;/li&gt;
&lt;li&gt;基本有序下数组下的快排&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="www.zspirytus.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized的正确食用方法</title>
    <link href="www.zspirytus.com/2018/07/18/synchronizedObjects/"/>
    <id>www.zspirytus.com/2018/07/18/synchronizedObjects/</id>
    <published>2018-07-18T04:27:13.000Z</published>
    <updated>2018-10-02T18:24:13.842Z</updated>
    
    <content type="html"><![CDATA[<img src="/18/synchronizedObjects/2018/07/18/synchronizedObjects/synchronized_objects_cover.jpeg" title="cover"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面的博客<a href="http://www.zspirytus.com/2018/07/13/aboutSynchronized/">《浅谈synchronized的实现原理》</a>谈到synchronized的实现原理，简单而言就是锁住了对象。但是似乎还比较抽象，本篇博客将解决：</p><ul><li>synchronized锁住的是哪个对象？</li><li>如何合理使用synchronized？<br>那么开始吧。<a id="more"></a></li></ul><h2 id="一、synchronized的两种用法"><a href="#一、synchronized的两种用法" class="headerlink" title="一、synchronized的两种用法"></a>一、synchronized的两种用法</h2><p>synchronized有两种基本用法说起，分别是同步语句块和同步方法。</p><h3 id="1-1-同步语句块"><a href="#1-1-同步语句块" class="headerlink" title="1.1.同步语句块"></a>1.1.同步语句块</h3><p>同步语句块是指被synchronized修饰的语句块，被synchronized修饰的语句块，被多个线程执行的过程是互斥的。同步语句块的写法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synchronizedStatement</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">        <span class="comment">//do Something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>同步语句块锁住的是括号中的对象，上例中锁住的是obj。这个例子是可以编译通过并且正常运行的，说明synchronized能够锁住<em>任意对象</em>。我们可以粗略的把<em>任意对象</em>分为<em>本类的实例对象</em>、<em>本类的类对象</em>以及其他普通对象。</p><h4 id="1-1-1-本类的实例对象"><a href="#1-1-1-本类的实例对象" class="headerlink" title="1.1.1.本类的实例对象"></a>1.1.1.本类的实例对象</h4><p>demo：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synchronizedStatement</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="comment">//do Something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这里，synchronized锁住的是<em>本类的实例对象</em>，需要注意的是：除非本类是单例，否则本类的实例对象在内存中是可以存在有多个的。</p><h4 id="1-1-2-本类的类对象"><a href="#1-1-2-本类的类对象" class="headerlink" title="1.1.2.本类的类对象"></a>1.1.2.本类的类对象</h4><p>demo：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synchronizedStatement</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SomeClass.class)&#123;</span><br><span class="line">        <span class="comment">// do Something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这里，synchronized锁住的是<em>本类的类对象</em>，对象SomeClass.class的类型是Class，本类的类对象在内存中<em>有且仅有一个</em>，因此可以把它看做是单例的。</p><h4 id="1-1-3-其他普通对象"><a href="#1-1-3-其他普通对象" class="headerlink" title="1.1.3.其他普通对象"></a>1.1.3.其他普通对象</h4><p>demo：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synchronizedStatement</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">        <span class="comment">// do Something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这里synchronized锁住的是除了以上提到的任意对象。这个对象的类型可以是HashMap、Integer等API自带类型，也可以是自己编写的类的实例对象、类对象等等。</p><h3 id="1-2-同步方法"><a href="#1-2-同步方法" class="headerlink" title="1.2.同步方法"></a>1.2.同步方法</h3><p>同步方法是指被synchronized修饰的方法，同步方法使得多个线程调用该方法的过程是互斥的。同步方法可以分为静态同步方法和非静态同步方法，锁住的对象是不同的。普通的同步方法锁住的对象是<em>本类的实例对象</em>；而静态同步方法锁住的对象是<em>本类的类对象</em>。以下是两种同步方法的写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Static Synchronized Method</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">staticSynchronizedMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Synchronized Method</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、同步方法和同步语句块的联系"><a href="#二、同步方法和同步语句块的联系" class="headerlink" title="二、同步方法和同步语句块的联系"></a>二、同步方法和同步语句块的联系</h2><p>从上面的解释可以看出，同步方法和同步语句块存在一些联系。事实上，从被锁住的对象的角度来看，synchronized(this)和同步方法是等价的；synchronized(SomeClass.class)和静态同步方法是等价的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两种同步是等价的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两种同步是等价的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addByMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SomeClass.class)&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三、同步与死锁"><a href="#三、同步与死锁" class="headerlink" title="三、同步与死锁"></a>三、同步与死锁</h2><p>同步是互斥的，我们可以简单的认为：我在用，其他人不能用；其他人在用，我不能用。一个经典的例子是：<del>哲♂学家</del>哲学家进餐问题。哲学家问题描述的是经过一系列同步操作后引发死锁的悲剧。因此同步可能会把我们往危险的陷阱——死锁那里带，在同步时我们必须要考虑死锁的情况。</p><h2 id="四、考虑死锁的情况"><a href="#四、考虑死锁的情况" class="headerlink" title="四、考虑死锁的情况"></a>四、考虑死锁的情况</h2><h3 id="4-1-synchronized可能发生死锁吗？"><a href="#4-1-synchronized可能发生死锁吗？" class="headerlink" title="4.1.synchronized可能发生死锁吗？"></a>4.1.synchronized可能发生死锁吗？</h3><p>synchronized锁是同步锁，它能够使得共享数据被多个线程操作前后保持数据一致性。既然是共享数据，就有可能会发生死锁。死锁发生的必要条件是：<br><blockquote><ul><li>互斥条件：进程对所分配到的资源进行排他性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其他进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放。</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其他进程占有，此时请求进程阻塞，但又对自己已获得的其他资源保持不放。</li><li>不剥夺条件：进程已获得的资源，在未使用完成之前，不能被剥夺，只能在使用完毕由其释放。</li><li>环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链，即进程集合P={P<sub>1</sub>,P<sub>2</sub>,… …,P<sub>n</sub>}中的P<sub>1</sub>等待P<sub>2</sub>的资源，P<sub>2</sub>等待P<sub>3</sub>的资源,… …,P<sub>n</sub>等待P<sub>1</sub>的资源。</li></ul><footer><strong>-</strong><cite><a href="https://book.douban.com/subject/26079463/" target="_blank" rel="noopener">《计算机操作系统》</a></cite></footer></blockquote><br>结合synchronized，我们分别考虑这四个条件：<br>1.对于互斥条件：synchronized是同步锁，多个线程竞争执行同步代码时，有且仅有一个线程获得锁，因此互斥条件是必然满足的。<br>2.对于请求和保持条件：因为同步方法和同步语句块原理相同，因此在这里考虑同步语句块。请求和保持，意味着每一个线程至少需要两个不同的锁，即同步语句块中嵌入同步语句块，并且锁的对象是不同的，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object_1)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(object_2)&#123;</span><br><span class="line">        <span class="comment">// do something synchronized or obtain other monitor lock</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这个例子中，如果线程获得object_1的对象锁，但是因object_2的对象锁被其他线程持有，因此它会被阻塞并保持持有object_1的对象锁。因此，请求和保持条件是可满足的。<br>3.不剥夺条件：如请求保持条件，直到线程获取全部需要的对象锁并执行完同步语句块，它是不会释放它获得的锁的。synchronized并没有强制剥夺某一个线程拥有锁的机制，因此，在没有人为的情况下，不剥夺条件必然满足。<br>4.假设请求和保持条件满足，并结合互斥条件和不剥夺条件。对于环路等待条件满足的情况下，情况就会这这样的，线程们都获得了至少一个锁并且都保持，并且任意一个线程，需要其他线程已经获得的锁（请求保持）。于是大家都和和气气地（不剥夺条件）互相等待。然后就成环了。接下来看一段简单的代码，这段代码实现的是线程t<sub>1</sub>和t<sub>2</sub>共同竞争object_1和object_2的对象锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String THREAD_1 = <span class="string">"Thread 1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String THREAD_2 = <span class="string">"Thread 2"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object_1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> Object object_2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, IllegalMonitorStateException </span>&#123;</span><br><span class="line">        Logcat(<span class="string">"try to get object_1's lock!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (object_1) &#123;</span><br><span class="line">            Logcat(<span class="string">"get object_1's lock!"</span>);</span><br><span class="line">            Logcat(<span class="string">"Sleeping ... ..."</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            Logcat(<span class="string">"wake up! try to get object_2's lock!"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (object_2) &#123;</span><br><span class="line">                Logcat(<span class="string">"get object_2's lock!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, IllegalMonitorStateException </span>&#123;</span><br><span class="line">        Logcat(<span class="string">"try to get object_2's lock!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (object_2) &#123;</span><br><span class="line">            Logcat(<span class="string">"get object_2's lock!"</span>);</span><br><span class="line">            Logcat(<span class="string">"try to get object_1's lock!"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (object_1) &#123;</span><br><span class="line">                Logcat(<span class="string">"get object_1's lock!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Logcat</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> DeadLockTest deadLockTest = <span class="keyword">new</span> DeadLockTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                deadLockTest.methodA();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalMonitorStateException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                deadLockTest.methodB();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalMonitorStateException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.setName(THREAD_1);</span><br><span class="line">        t2.setName(THREAD_2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        Logcat(<span class="string">"Finish Successfully!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Thread 1: try to get object_1's lock!</span></span><br><span class="line"><span class="comment">// Thread 1: get object_1's lock!</span></span><br><span class="line"><span class="comment">// Thread 1: Sleeping ... ...</span></span><br><span class="line"><span class="comment">// Thread 2: try to get object_2's lock!</span></span><br><span class="line"><span class="comment">// Thread 2: get object_2's lock!</span></span><br><span class="line"><span class="comment">// Thread 2: try to get object_1's lock!</span></span><br><span class="line"><span class="comment">// Thread 1: wake up! try to get object_2's lock!</span></span><br></pre></td></tr></table></figure><br>这段代码大概率会出现死锁。发生死锁时，输出如62~68行。代码的执行顺序是不确定的，但是从这个例子的输出来看，要发生死锁，必然存在子顺序：<br>1.t<sub>1</sub>获得object_1的对象锁<br>2.t<sub>2</sub>获得object_2的对象锁<br>3.JVM去执行其他调度，这里就用休眠操作来模拟<br>4.t<sub>1</sub>尝试获取object_2的对象锁，但已被占用，阻塞。<br>5.t<sub>2</sub>尝试获取object_1的对象锁，但已被占用，阻塞。<br>这里就是环路等待的情况了！t<sub>1</sub>等t<sub>2</sub>，t<sub>2</sub>等t<sub>1</sub>，除非人为干预，否则永远持续。<br>从上面来看，使用synchronized是有可能发生死锁的！因为四个条件的合取并不恒为假。因此在使用时要慎重考虑，因为一旦发生死锁，程序就死掉。</p><h3 id="4-2-死锁的避免"><a href="#4-2-死锁的避免" class="headerlink" title="4.2.死锁的避免"></a>4.2.死锁的避免</h3><p>死锁的发生是有条件的。为了避免发生死锁，我们只需要破坏条件，使其不满足即可。分别考虑四个条件：<br>1.互斥条件。互斥条件必然满足的，破坏是不可能破坏的。<br>2.请求等待条件、不剥夺条件和环路等待条件互相配合。在请求等待时，线程至少持有一个对象锁。如果发生死锁时，通过破坏不剥夺条件和环路等待条件，有不多于[线程个数 - 共享资源个数]个线程主动释放当前持有的锁，那么尴尬的局面就可以缓解。为什么是不多于[线程个数 - 共享资源个数]个线程而不是全部线程？以<del>哲♂学家</del>哲学家进餐问题为例，考虑情况：所有哲学家都饿了，然后他们同时拿到左边的筷子。这个时候他们同时wait()，放下左边的筷子(释放资源)，并等待通知其他哲学家用完的通知(notify())。然而，从上帝视角来看，情况是这样的：所有哲学家先同时拿起左边的筷子，然后发现不对，然后全部放下左边的筷子，然后等，最后饿死。<br>这里的线程个数为2，共享资源个数为1，因为对于任意两个相邻的哲学家，他们会竞争1根筷子。因此，在这个例子中，当发生死锁时，任意一对相邻的哲学家，只要有[2 - 1]个哲学家放弃筷子，这时候死锁就能解除。因此，上面会发生死锁的代码可以如下改进：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String THREAD_1 = <span class="string">"Thread 1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String THREAD_2 = <span class="string">"Thread 2"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object_1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> Object object_2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isObject1Locked = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isObject2Wait = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, IllegalMonitorStateException </span>&#123;</span><br><span class="line">        Logcat(<span class="string">"try to get object_1's lock!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (object_1) &#123;</span><br><span class="line">            isObject1Locked = <span class="keyword">true</span>;</span><br><span class="line">            Logcat(<span class="string">"get object_1's lock!"</span>);</span><br><span class="line">            Logcat(<span class="string">"Sleeping ... ..."</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            Logcat(<span class="string">"wake up! try to get object_2's lock!"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (object_2) &#123;</span><br><span class="line">                Logcat(<span class="string">"get object_2's lock!"</span>);</span><br><span class="line">                <span class="keyword">if</span> (isObject2Wait) &#123;</span><br><span class="line">                    Logcat(<span class="string">"I will finish, notify!"</span>);</span><br><span class="line">                    object_2.notify();</span><br><span class="line">                    isObject2Wait = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isObject1Locked = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, IllegalMonitorStateException </span>&#123;</span><br><span class="line">        Logcat(<span class="string">"try to get object_2's lock!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (object_2) &#123;</span><br><span class="line">            Logcat(<span class="string">"get object_2's lock!"</span>);</span><br><span class="line">            Logcat(<span class="string">"try to get object_1's lock!"</span>);</span><br><span class="line">            <span class="keyword">if</span> (isObject1Locked) &#123;</span><br><span class="line">                isObject2Wait = <span class="keyword">true</span>;</span><br><span class="line">                object_2.wait();</span><br><span class="line">                Logcat(<span class="string">"Fortunately, object_1 is locked, release object_2's lock and wait!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (object_1) &#123;</span><br><span class="line">                isObject1Locked = <span class="keyword">true</span>;</span><br><span class="line">                Logcat(<span class="string">"get object_1's lock!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            isObject1Locked = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Logcat</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> DeadLockTest deadLockTest = <span class="keyword">new</span> DeadLockTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                deadLockTest.methodA();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalMonitorStateException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                deadLockTest.methodB();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalMonitorStateException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.setName(THREAD_1);</span><br><span class="line">        t2.setName(THREAD_2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        Logcat(<span class="string">"Finish Successfully!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Thread 1: try to get object_1's lock!</span></span><br><span class="line"><span class="comment">// Thread 2: try to get object_2's lock!</span></span><br><span class="line"><span class="comment">// Thread 1: get object_1's lock!</span></span><br><span class="line"><span class="comment">// Thread 2: get object_2's lock!</span></span><br><span class="line"><span class="comment">// Thread 2: try to get object_1's lock!</span></span><br><span class="line"><span class="comment">// Thread 1: Sleeping ... ...</span></span><br><span class="line"><span class="comment">// Thread 1: wake up! try to get object_2's lock!</span></span><br><span class="line"><span class="comment">// Thread 1: get object_2's lock!</span></span><br><span class="line"><span class="comment">// Thread 1: I will finish, notify!</span></span><br><span class="line"><span class="comment">// Thread 2: Fortunately, object_1 is locked, release object_2's lock and wait!</span></span><br><span class="line"><span class="comment">// Thread 2: get object_1's lock!</span></span><br><span class="line"><span class="comment">// main: Finish Successfully!</span></span><br></pre></td></tr></table></figure></p><p>这段代码的原理是：<br>2.1.当线程t<sub>2</sub>准备获取object_1的对象锁时，如果object_1已被锁住则放弃当前持有的object_2锁；<br>2.2.当线程t<sub>1</sub>将要释放object_2的对象锁时，如果t<sub>1</sub>处于等待状态，则通知它准备。</p><h2 id="五、题外话：不够用？试试ReetrantLock！"><a href="#五、题外话：不够用？试试ReetrantLock！" class="headerlink" title="五、题外话：不够用？试试ReetrantLock！"></a>五、题外话：不够用？试试ReetrantLock！</h2><p>ReetrantLock在Java8 api docs中是被这么描述的：<br><blockquote><p>A reentrant mutual exclusion Lock with the same basic behavior and semantics as the implicit monitor lock accessed using synchronized methods and statements, but with extended capabilities.</p></blockquote><br>一个与基于monitor锁实现的同步方法或同步语句块有相同的行为和语义的可重入互斥锁，并具有扩展功能。<br>一个简单的demo：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>同步前只需要调用ReentrantLock.lock()锁住，使用完毕一定要解锁。为了增加可读性，可使用try…finally结构。<br>ReentrantLock的功能不仅限于此，它提供尝试获得锁，失败就放弃的功能，demo如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">             i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">": failed to get lock!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lock.isHeldByCurrentThread())&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>lock.tryLock(1, TimeUnit.SECONDS) 表示尝试获得锁，如果超过一秒还没能获得锁则放弃获得并退出，不会重试。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>synchronized锁住的是哪个对象？<br>对于同步语句块，synchronized锁住的是括号中的对象。对于同步方法，静态同步方法中synchronized锁住的是<em>本类的类对象</em>，而普通同步方法中的synchronized锁住的是<em>本类的实例对象</em></li><li>如何合理使用synchronized？<br>synchronized是同步的，互斥的。在使用的时候必须考虑死锁的情况。通过考察发生死锁的四个必要条件，然后逐一破坏（互斥条件的破坏是不可能的），避免死锁的发生。在复杂的场景，可以考虑使用ReentrantLock。</li></ul><h2 id="七、感想"><a href="#七、感想" class="headerlink" title="七、感想"></a>七、感想</h2><p>在明白原理的前提下，很多问题都能通过原理来得到解答。我第一次接触synchronized的时候，以为它锁的是代码块。然而明白原理后，不仅明白了锁的是对象，而且还明白了锁哪个对象，有什么区别。这是我对于本文的前半部分的感想。重点是死锁的部分，我翻了很多资料，包括大二的操作系统教材。在第一次学同步互斥的时候是一脸懵逼的，感觉难就简单的记一记背一背，没有理解。通过这次写博客的机会，我琢磨了好久，反反复复看死锁那章，终于理解了。相比死记硬背，理解后更能举一反三，融会贯通。所以看这种原理性的书还是要耐心，理解才好。还有，在查资料的过程中发现有很多名词，像多叉树一样互相联系着，感觉自己还有很多不懂，Java这条路还是任重道远。暂时就这么多，就这样吧。水平有限，如果本文有误，还望指正，谢谢~</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/18/synchronizedObjects/2018/07/18/synchronizedObjects/synchronized_objects_cover.jpeg&quot; title=&quot;cover&quot;&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前面的博客&lt;a href=&quot;http://www.zspirytus.com/2018/07/13/aboutSynchronized/&quot;&gt;《浅谈synchronized的实现原理》&lt;/a&gt;谈到synchronized的实现原理，简单而言就是锁住了对象。但是似乎还比较抽象，本篇博客将解决：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;synchronized锁住的是哪个对象？&lt;/li&gt;
&lt;li&gt;如何合理使用synchronized？&lt;br&gt;那么开始吧。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="www.zspirytus.com/tags/Java/"/>
    
      <category term="多线程" scheme="www.zspirytus.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>浅谈synchronized的实现原理</title>
    <link href="www.zspirytus.com/2018/07/13/aboutSynchronized/"/>
    <id>www.zspirytus.com/2018/07/13/aboutSynchronized/</id>
    <published>2018-07-13T12:15:12.000Z</published>
    <updated>2018-10-02T18:25:50.093Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/13/aboutSynchronized/about_synchronized_cover.jpeg" alt="cover"><br><img src="/13/aboutSynchronized/2018/07/13/aboutSynchronized/about_synchronized_cover.jpeg" title="cover"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Synchronized是Java中的重量级锁，在我刚学Java多线程编程时，我只知道它的实现和monitor有关，但是synchronized和monitor的关系，以及monitor的本质究竟是什么，我并没有尝试理解，而是选择简单的略过。在最近的一段时间，由于实际的需要，我又把这个问题翻出来，Google了很多资料，整个实现的过程总算是弄懂了，为了以防遗忘，便整理成了这篇博客。<br>在本篇博客中，我将以class文件为突破口，试图解释Synchronized的实现原理。<br><a id="more"></a></p><h2 id="从java代码的反汇编说起"><a href="#从java代码的反汇编说起" class="headerlink" title="从java代码的反汇编说起"></a>从java代码的反汇编说起</h2><p>很容易的想到，可以从<em>程序的行为</em>来了解synchronized的实现原理。但是在源代码层面，似乎看不出synchronized的实现原理。锁与不锁的区别，似乎仅仅只是有没有被synchronized修饰。不如把目光放到更加底层的汇编上，看看能不能找到突破口。<em>javap</em>是官方提供的*.class文件分解器，它能帮助我们获取*.class文件的汇编代码。具体用法可参考<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javap.html" target="_blank" rel="noopener">这里</a>。 接下来我会使用javap命令对*.class文件进行反汇编。<br>编写文件Test.java:<br><figure class="highlight java"><figcaption><span>Test.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addI_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">addI_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>生成class文件，并获取对Test.class反汇编的结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Test.java</span><br><span class="line">javap -v Test.class</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/zhangkunwei/Desktop/Test.class</span><br><span class="line">  Last modified Jul 13， 2018; size 453 bytes</span><br><span class="line">  MD5 checksum ada74ec8231c64230d6ae133fee5dd16</span><br><span class="line">  Compiled from &quot;Test.java&quot;</span><br><span class="line">  ... ...</span><br><span class="line">  public void addI_1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3， locals=3， args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: dup</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: monitorenter</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: dup</span><br><span class="line">         6: getfield      #2                  // Field i:I</span><br><span class="line">         9: iconst_1</span><br><span class="line">        10: iadd</span><br><span class="line">        11: putfield      #2                  // Field i:I</span><br><span class="line">        14: aload_1</span><br><span class="line">        15: monitorexit</span><br><span class="line">        16: goto          24</span><br><span class="line">        19: astore_2</span><br><span class="line">        20: aload_1</span><br><span class="line">        21: monitorexit</span><br><span class="line">        22: aload_2</span><br><span class="line">        23: athrow</span><br><span class="line">        24: return</span><br><span class="line">  ... ...</span><br><span class="line">    public synchronized void addI_2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC， ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=3， locals=1， args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: dup</span><br><span class="line">         2: getfield      #2                  // Field i:I</span><br><span class="line">         5: iconst_1</span><br><span class="line">         6: iadd</span><br><span class="line">         7: putfield      #2                  // Field i:I</span><br><span class="line">        10: return</span><br><span class="line">   ... ...</span><br></pre></td></tr></table></figure><p>通过反汇编结果，我们可以看到：</p><ul><li>进入被synchronized修饰的语句块时会执行<strong>monitorenter</strong>，离开时会执行<strong>monitorexit</strong>。</li><li>相较于被synchronized修饰的语句块，被synchronized修饰的方法中没有指令<strong>monitorenter</strong>和<strong>monitorexit</strong>，且flags中多了ACC_SYNCHRONIZED标志。<br><strong>monitorenter</strong>和<strong>monitorexit</strong>指令是做什么的？同步语句块和同步方法的实现原理有何不同？遇事不决查文档，看看官方文档的解释。</li></ul><h3 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h3><blockquote><p><strong>Description</strong><br>The <em>objectref</em> must be of type <em>reference</em>.</p><p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with <em>objectref</em>， as follows:</p><ul><li><p>If the entry count of the monitor associated with <em>objectref</em> is zero， the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.</p></li><li><p>If the thread already owns the monitor associated with <em>objectref</em>， it reenters the monitor， incrementing its entry count.</p></li><li><p>If another thread already owns the monitor associated with <em>objectref</em>， the thread blocks until the monitor’s entry count is zero， then tries again to gain ownership.</p></li></ul><p><strong>Notes</strong></p><ul><li>A monitorenter instruction may be used with one or more monitorexit instructions (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit" target="_blank" rel="noopener">§monitorexit</a>) to implement a synchronized statement in the Java programming language (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.14" target="_blank" rel="noopener">§3.14</a>). The monitorenter and monitorexit instructions are not used in the implementation of synchronized methods， although they can be used to provide equivalent locking semantics. Monitor entry on invocation of a synchronized method， and monitor exit on its return， are handled implicitly by the Java Virtual Machine’s method invocation and return instructions， as if monitorenter and monitorexit were used.</li></ul><footer><strong>Java Virtual Machine Specification -</strong><cite><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter" target="_blank" rel="noopener">monitorenter</a></cite></footer></blockquote><p>简单翻译一下:<br>指令<strong>monitorenter</strong>的操作的必须是一个对象的引用，且其类型为引用。每一个对象都会有一个<strong>monitor</strong>与之关联，当且仅当<strong>monitor</strong>被(其他(线程)对象)持有时，<strong>monitor</strong>会被锁上。其执行细节是，当一个线程尝试持有某个对象的<strong>monitor</strong>时：</p><ul><li>如果该对象的<strong>monitor</strong>中的<strong>entry count</strong>==0，则将<strong>entry count</strong>置1，并令该线程为<strong>monitor</strong>的持有者。</li><li>如果该线程已经是该对象的<strong>monitor</strong>的持有者，那么重新进入<strong>monitor</strong>，并使得<strong>entry count</strong>自增一次。</li><li>如果其他线程已经持有该对象的<strong>monitor</strong>，则该线程将会被阻塞，直到<strong>monitor</strong>中的<strong>entry count</strong>==0，然后重新尝试持有。<br>注意:<br><strong>monitorenter</strong>必须与一个以上<strong>monitorexit</strong>配合使用来实现Java中的同步语句块。而同步方法却不是这样的:同步方法不使用<strong>monitorenter</strong>和<strong>monitorexit</strong>来实现。当同步方法被调用时，<strong>Monitor</strong>介入；当同步方法return时，<strong>Monitor</strong>退出。这两个操作，都是被<strong>JVM</strong>隐式的handle的，就好像这两个指令被执行了一样。</li></ul><h3 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h3><blockquote><p><strong>Description</strong></p><ul><li><p>The <em>objectref</em> must be of type <em>reference</em>.</p></li><li><p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by <em>objectref</em>.</p></li><li><p>The thread decrements the entry count of the monitor associated with <em>objectref</em>. If as a result the value of the entry count is zero， the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p></li></ul><footer><strong>Java Virtual Machine Specification -</strong><cite><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit" target="_blank" rel="noopener">monitorexit</a></cite></footer></blockquote><p>简单翻译一下:<br>指令<strong>monitorenter</strong>的操作的必须是一个对象的引用，且其类型为引用。并且：</p><ul><li>执行<strong>monitorexit</strong>的线程必须是<strong>monitor</strong>的持有者。</li><li>执行<strong>monitorexit</strong>的线程让<strong>monitor</strong>的<strong>entry count</strong>自减一次。如果最后<strong>entry count</strong>==0，这个线程就不再是<strong>monitor</strong>的持有者，意味着其他被阻塞线程都能够尝试持有<strong>monitor</strong></li></ul><p>根据以上信息，上面的疑问得到了解释：<br>1.<strong>monitorenter</strong>和<strong>monitorexit</strong>是做什么的？<br><strong>monitorenter</strong>能“锁住”对象。当一个线程获取<strong>monitor</strong>的锁时，其他请求访问共享内存空间的线程无法取得访问权而被阻塞；<strong>monitorexit</strong>能“解锁”对象，唤醒因没有取得共享内存空间访问权而被阻塞的线程。</p><p>2.为什么一个<strong>monitorenter</strong>与多个<strong>monitorexit</strong>对应，是一对多，而不是一一对应？<br>一对多的原因，是为了保证：执行<strong>monitorenter</strong>指令，后面一定会有一个<strong>monitorexit</strong>指令被执行。上面的例子中，程序正常执行，在离开同步语句块时执行第一个<strong>monitorexit</strong>；Runtime期间程序抛出Exception或Error，而后执行第二个<strong>monitorexit</strong>以离开同步语句块。</p><p>3.为什么同步语句块和同步方法的反汇编代码略有不同？<br>同步语句块是使用<strong>monitorenter</strong>和<strong>monitorexit</strong>实现的；而同步方法是<strong>JVM</strong>隐式处理的，效果与<strong>monitorenter</strong>和<strong>monitorexit</strong>一样。并且，同步方法的flags也不一样，多了一个ACC_SYNCHRONIZED标志，这个标志是告诉<strong>JVM</strong>：这个方法是一个同步方法，可以参考<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.6-200-A.1" target="_blank" rel="noopener">这里</a>。</p><h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>在上一个部分，我们容易得出一个结论：synchronized的实现和<strong>monitor</strong>有关。<strong>monitor</strong>又是什么呢？从文档的描述可以看出，<strong>monitor</strong>类似于操作系统中的<strong>互斥量</strong>这个概念：不同对象对共享内存空间的访问是互斥的。在<strong>JVM</strong>（<strong>Hotspot</strong>）中，<strong>monitor</strong>是由<strong>ObjectMonitor</strong>实现，其主要的数据结构如下:<br><figure class="highlight c"><figcaption><span>ObjectMonitor</span><a href="https://github.com/JetBrains/jdk8u_hotspot/blob/master/src/share/vm/runtime/objectMonitor.hpp#L140" target="_blank" rel="noopener">ObjectMonitor.hpp</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>;</span><br><span class="line">    _waiters      = <span class="number">0</span>，</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;   <span class="comment">//指向当前monitor的持有者 </span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>;   <span class="comment">//持有monitor后，调用的wait()的线程集合</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ;  <span class="comment">//尝试持有monitor失败后被阻塞的线程集合</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">    _previous_owner_tid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，我们可以</p><ul><li>通过修改_owner来指明<strong>monitor</strong>锁的拥有者；</li><li>通过读取_EntryList来获取因获取锁失败而被阻塞的线程集合；</li><li>通过读取_WaitSet来获取在获得锁后主动放弃锁的线程集合。</li></ul><p>到这里，synchronized的实现原理已经基本理清楚了，但是还有一个未解决的疑问：线程是怎么知道<strong>monitor</strong>的地址的？线程只有知道它的地址，才能够访问它，然后才能与以上的分析联系上。答案是<strong>monitor</strong>的地址在Java对象头中。</p><h2 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h2><p>在Java中，每一个对象的组成成分中都有一个Java对象头。通过对象头，我们可以获取对象的相关信息。<br>这是Java对象头的数据结构(32位虚拟机下):<br><img src="/13/aboutSynchronized/2018/07/13/aboutSynchronized/Java对象头数据结构.png" title="Java对象头数据结构"><br>其中的Mark Word，它是一个可变的数据结构，即它的数据结构是依情况而定的。下面是在对应的锁状态下，Mark Word的数据结构(32位虚拟机下)：<br><img src="/13/aboutSynchronized/2018/07/13/aboutSynchronized/Mark_Word数据结构.png" title="Mark Word数据结构"><br>synchronized是一个重量级锁，所以对应图中的重量级锁状态。其中有一个字段是：指向重量级锁的指针，共占用25+4+1=30bit，它的内容就是这个对象的引用所关联的<strong>monitor</strong>的地址。<br>线程可以通过Java对象头中的Mark Word字段，来获取<strong>monitor</strong>的地址，以便获得锁。</p><h2 id="回到最初的问题"><a href="#回到最初的问题" class="headerlink" title="回到最初的问题"></a>回到最初的问题</h2><p>synchronized的实现原理是什么？从上面的分析来看，答案已经显而易见了。当多个线程一起访问共享内存空间时，这些线程可以通过synchronized锁住<em>对象</em>的对象头中，根据Mark Word字段来访问该对象所关联的<strong>monitor</strong>，并尝试获取。当一个线程成功获取<strong>monitor</strong>后，其他与之竞争<strong>monitor</strong>持有权的线程将会被阻塞，并进入EntryList。当该线程操作完毕后，释放锁，因争用<strong>monitor</strong>失败而被阻塞的线程就会被唤醒，然后重复以上步骤。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>我发现其实大部分答案都可以从文档中得到，所以以后遇到问题还是要尝试从文档中找到答案。<br>本人水平有限，如果本文有错误，还望指正，谢谢~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/13/aboutSynchronized/about_synchronized_cover.jpeg&quot; alt=&quot;cover&quot;&gt;&lt;br&gt;&lt;img src=&quot;/13/aboutSynchronized/2018/07/13/aboutSynchronized/about_synchronized_cover.jpeg&quot; title=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Synchronized是Java中的重量级锁，在我刚学Java多线程编程时，我只知道它的实现和monitor有关，但是synchronized和monitor的关系，以及monitor的本质究竟是什么，我并没有尝试理解，而是选择简单的略过。在最近的一段时间，由于实际的需要，我又把这个问题翻出来，Google了很多资料，整个实现的过程总算是弄懂了，为了以防遗忘，便整理成了这篇博客。&lt;br&gt;在本篇博客中，我将以class文件为突破口，试图解释Synchronized的实现原理。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="www.zspirytus.com/tags/Java/"/>
    
      <category term="多线程" scheme="www.zspirytus.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hello World!</title>
    <link href="www.zspirytus.com/2018/05/21/HelloWorld/"/>
    <id>www.zspirytus.com/2018/05/21/HelloWorld/</id>
    <published>2018-05-21T08:58:40.000Z</published>
    <updated>2018-07-19T16:07:18.786Z</updated>
    
    <content type="html"><![CDATA[<p>Hello World！<br>博客终于搭起来啦！<br>搭博客没有别的目的，只为<strong>输出倒逼输入</strong>，自己给别人讲清楚了，才能对知识的理解更近一步！<br>第一次也不知道该怎么说，就以我第一个编写的程序结尾吧！<br><figure class="highlight c"><figcaption><span>Best Practice</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hello World！&lt;br&gt;博客终于搭起来啦！&lt;br&gt;搭博客没有别的目的，只为&lt;strong&gt;输出倒逼输入&lt;/strong&gt;，自己给别人讲清楚了，才能对知识的理解更近一步！&lt;br&gt;第一次也不知道该怎么说，就以我第一个编写的程序结尾吧！&lt;br&gt;&lt;figure class=
      
    
    </summary>
    
    
  </entry>
  
</feed>
